CRITICAL LIMITATIONS TO AVOID
1. File Size & Context Window Limits
Problem: AI tools have finite "working memory" (context windows) - typically 64k-128k tokens. Large files exceed this, causing:

Corrupted edits and syntax errors
Loss of global context
"Lost in the middle" - AI forgets important details
Hallucinations (plausible but wrong code)
RULES:

âœ… Hard Limit: Keep files under 500 lines (ideal)
âš ï¸ Warning Zone: 500-1,000 lines (needs monitoring)
âŒ Danger Zone: 1,000-2,000 lines (suggest refactoring)
ðŸš« BLOCKED: 2,000+ lines (MUST be split before any AI edits)
Enforcement: Before writing code, ASK:

"Will this file exceed 500 lines?"
"Can this be split into smaller modules?"
If yes to either, propose modular structure FIRST
2. Monolithic Code Organization
Problem: AI tools can't understand cross-file dependencies in large codebases

RULES FOR ALL PROJECTS:

Web Development (HTML/CSS/JS):
âŒ NO inline CSS > 100 lines (extract to separate file)
âŒ NO inline JavaScript > 200 lines (extract to separate file)
âœ… Use <link> for CSS: <link rel="stylesheet" href="styles.css">
âœ… Use <script src=""> for JavaScript modules
âœ… Split large CSS into: base.css, components.css, utilities.css
âœ… Split large JS into feature modules: auth.js, forms.js, api.js
Android Development (Kotlin/Java):
âŒ NO Activities > 300 lines (use Fragments + ViewModels)
âŒ NO ViewModels > 400 lines (extract to Repository/UseCase layer)
âŒ NO XML layouts > 200 lines (use <include> for reusable components)
âœ… One ViewModel per screen
âœ… Extract shared UI to custom Views or Composables
âœ… Use dependency injection (Hilt/Dagger)
âœ… Separate concerns: UI Layer â†’ ViewModel â†’ Repository â†’ Data Source
Python/Backend Development:
âŒ NO modules > 500 lines (split into submodules)
âŒ NO classes > 300 lines (extract mixins/utilities)
âœ… One class per file (unless tightly coupled)
âœ… Group related functions in separate utilities
âœ… Use __init__.py to organize module imports cleanly
3. Cross-File Dependencies & Architecture
Problem: AI can't track dependencies across multiple files, causing broken refactors

RULES:

âœ… Explicit imports: Always use explicit imports, never import *
âœ… Clear interfaces: Define clear contracts (interfaces/protocols/abstract classes)
âœ… Dependency injection: Don't hardcode dependencies
âœ… Loose coupling: Modules should be independently understandable
âŒ Avoid: Circular dependencies between modules
âŒ Avoid: Global state and "God classes"
Architecture Patterns to Use:

MVC/MVVM for UI applications
Repository Pattern for data access
Service Layer for business logic
Feature-based folder structure (not type-based)
Example:

âœ… Good (Feature-based):
/features
  /auth
    - LoginScreen.kt
    - AuthViewModel.kt
    - AuthRepository.kt
  /profile
    - ProfileScreen.kt
    - ProfileViewModel.kt
âŒ Bad (Type-based):
/viewmodels (10+ files)
/screens (10+ files)
/repositories (10+ files)
4. Code Quality & Documentation
Problem: AI generates worse code when context is unclear or inconsistent

RULES:

âœ… Meaningful names: Use descriptive variable/function names
Good: calculateUserMonthlyTotal(userId, month)
Bad: calc(u, m) or process_data(x, y)
âœ… Consistent style: Follow established style guides (PEP 8, ktlint, ESLint)
âœ… Comments for complexity: Explain WHY, not WHAT
// âœ… Good: Explains reasoning
// Using debounce to prevent API spam from rapid user input
fun searchUsers(query: String) { ... }
// âŒ Bad: States the obvious
// This function searches for users
fun searchUsers(query: String) { ... }
âœ… Document architectural decisions: Keep ARCHITECTURE.md or similar
âœ… Type hints/annotations: Use them everywhere (TypeScript, Python type hints, Kotlin types)
5. Security & Review Requirements
Problem: AI can generate code with security vulnerabilities or expose secrets

NON-NEGOTIABLE RULES:

ðŸš¨ NEVER trust AL-generated code blindly
âœ… Code review: ALL AI-generated code must be reviewed
âœ… Security scan: Run SAST tools (SonarQube, Snyk, etc.)
âŒ NO hardcoded secrets: Use environment variables/secret managers
âŒ NO exposed API keys: Even in comments or test files
âœ… Test coverage: Minimum 70% for AI-generated code
âœ… Validate inputs: All user inputs must be sanitized
Security Checklist for AI Code:

 No SQL injection vulnerabilities
 No XSS (Cross-Site Scripting) risks
 Proper authentication/authorization
 No sensitive data in logs
 HTTPS/TLS for all external connections
6. Context Management Strategy
Problem: AI loses track in long sessions or complex tasks

RULES:

âœ… Break down tasks: Split complex features into 5-10 subtasks
âœ… One feature at a time: Don't mix unrelated changes
âœ… Close irrelevant files: Only keep 3-5 files open in IDE
âœ… Clear prompts: Be specific about requirements
Good: "Create a login form with email/password validation, show errors inline, and call /api/auth/login on submit"
Bad: "Make a login page"
âœ… Start fresh: For new features, start a new AI conversation
7. Testing & Validation
Problem: AI-generated code may have subtle bugs or logic errors

MANDATORY PRACTICES:

âœ… Write tests FIRST (TDD): Provide AI with test cases as context
âœ… Automated testing: Unit + Integration tests for all features
âœ… Manual testing: Test all user flows personally
âœ… Edge cases: Specifically test error conditions
âœ… Performance testing: Validate for slow operations
ðŸ“‹ PRE-PROJECT CHECKLIST
Before starting ANY new project with AI assistance:

Setup Phase:
 Define maximum file size limits for project type
 Set up automated linters (ESLint, ktlint, black, etc.)
 Configure pre-commit hooks (file size check, style check)
 Create folder structure following modular principles
 Set up testing framework
 Configure security scanning tools
 Create ARCHITECTURE.md documenting patterns to follow
During Development:
 Monitor file sizes after each AI interaction
 Review all AI-generated code for quality/security
 Run tests after accepting AI suggestions
 Keep related files open, close unrelated ones
 Break down complex tasks before asking AI
Red Flags to Watch For:
ðŸš© File approaching 500 lines â†’ Refactor now
ðŸš© AI suggesting copied code â†’ Check for better abstraction
ðŸš© AI "hallucinating" functions â†’ Verify against docs
ðŸš© Complex nested logic â†’ Simplify before accepting
ðŸš© Missing error handling â†’ Add it yourself
ðŸŽ¯ ENFORCEMENT
When AI Tool Should Refuse: If I ask for changes that would:

Create a file > 500 lines
Add > 100 lines to a file > 400 lines
Create circular dependencies
Duplicate code instead of abstracting
Mix multiple unrelated features
AI Response Should Be: "This change would create a [FILE SIZE / ARCHITECTURE / DUPLICATION] problem. Here's a better approach: [MODULAR SOLUTION]"

âœ… CONFIRMATION REQUIRED
At the start of EVERY new project or major feature:

AI must acknowledge:

"I understand file size limits and will proactively suggest splitting"
"I will follow [PROJECT TYPE] architecture best practices"
"I will not generate code exceeding defined thresholds"
"I will flag security risks and require validation"
"I understand this project prioritizes QUALITY over speed"
Do you acknowledge and agree to follow ALL these rules for this project?

Last Updated: Based on real-world experience and industry research (2024) Applies To: ALL projects - Web, Mobile, Backend, Scripts, etc. No Exceptions: These are ironclad rules, not suggestions