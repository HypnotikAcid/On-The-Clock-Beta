# Project Snapshot (Lite)
Generated: 2025-09-30 21:10:53Z

# Repository Tree (depth 2)

_tree not installed; using find_
```text
.
.cache
.cache/replit
.cache/pip
.local
.local/state
.pythonlibs
.pythonlibs/lib
.pythonlibs/bin
.upm
.upm/store.json
.config
.config/.semgrep
attached_assets
attached_assets/screenshot-1758538526629.png
attached_assets/screenshot-1758538829650.png
attached_assets/image_1758590639730.png
attached_assets/image_1758594262126.png
attached_assets/image_1758597318619.png
attached_assets/image_1758598321300.png
attached_assets/image_1758599254954.png
attached_assets/image_1758600138635.png
attached_assets/image_1758602632591.png
attached_assets/image_1758604238762.png
attached_assets/image_1758604977179.png
attached_assets/Screenshot_20250923-123322_1758645227346.png
attached_assets/Pasted-Time-Log-09-23-12-06-15-127-0-0-1-23-Sep-2025-16-06-15-GET-HTTP-1-1-200-09-23-13-15-56-0-1758658163594_1758658163596.txt
attached_assets/Pasted--Security-Scanner-Security-Scanner-Run-a-scan-to-check-for-potential-security-risks-in-your-applicat-1758658429618_1758658429620.txt
attached_assets/Screenshot_20250923-181958_1758666351680.png
attached_assets/image_1758666619896.png
attached_assets/Pasted-2025-09-23-22-44-06-94-e6595b93-User-File-home-runner-workspace-bot-py-line-3171-in-manual-c-1758683319700_1758683319702.txt
attached_assets/image_1758684310805.png
attached_assets/Pasted-2025-09-23-23-50-53-21-9eb187dd-User-2025-09-24-03-50-53-ERROR-discord-app-commands-tree-Ig-1758685881782_1758685881783.txt
attached_assets/Pasted-2025-09-23-23-55-35-21-9eb187dd-User-2025-09-24-03-55-35-ERROR-discord-app-commands-tree-Ig-1758686159791_1758686159791.txt
attached_assets/Pasted-2025-09-23-23-57-50-19-9eb187dd-User-2025-09-24-03-57-50-ERROR-discord-app-commands-tree-Ig-1758686294253_1758686294254.txt
attached_assets/Pasted-2025-09-24-00-00-10-05-9eb187dd-User-2025-09-24-04-00-10-ERROR-discord-app-commands-tree-Ig-1758686430844_1758686430845.txt
attached_assets/Pasted-2025-09-24-00-13-20-54-c02e4abc-User-2025-09-24-04-13-20-ERROR-discord-app-commands-tree-Ig-1758687246502_1758687246502.txt
attached_assets/Pasted-2025-09-24-00-23-29-72-c02e4abc-User-2025-09-24-04-23-29-ERROR-discord-app-commands-tree-Ig-1758687843767_1758687843769.txt
attached_assets/Pasted-2025-09-24-00-25-07-63-c02e4abc-User-2025-09-24-04-25-07-ERROR-discord-app-commands-tree-Ig-1758687983770_1758687983771.txt
attached_assets/Pasted-2025-09-24-00-27-39-69-c02e4abc-User-2025-09-24-04-27-39-ERROR-discord-app-commands-tree-Ig-1758688093297_1758688093298.txt
attached_assets/image_1758926977786.png
attached_assets/Screenshot_20250927-124531_1758991565554.png
attached_assets/Screenshot_20250927-124804_1758991700653.png
attached_assets/Screenshot_20250927-130333_1758992707548.png
attached_assets/Screenshot_20250927-124804_1759021579450.png
attached_assets/Screenshot_20250927-210608_1759021585809.png
attached_assets/Screenshot_20250928-141413_1759083268348.png
attached_assets/Screenshot_20250928-141407_1759083273734.png
attached_assets/Screenshot_20250928-141413_1759083347446.png
attached_assets/Screenshot_20250928-141407_1759083351827.png
attached_assets/Screenshot_20250928-175902_1759096762450.png
attached_assets/image_1759100290395.png
attached_assets/image_1759100302986.png
attached_assets/image_1759100319220.png
attached_assets/image_1759100550810.png
attached_assets/image_1759100558847.png
attached_assets/image_1759100571187.png
attached_assets/image_1759104522724.png
attached_assets/image_1759107249553.png
attached_assets/image_1759115211635.png
attached_assets/image_1759117796484.png
attached_assets/image_1759118854889.png
attached_assets/image_1759122661343.png
attached_assets/image_1759122893100.png
attached_assets/image_1759125593167.png
attached_assets/image_1759126425597.png
attached_assets/image_1759127476602.png
attached_assets/image_1759127592004.png
attached_assets/image_1759127888721.png
attached_assets/image_1759128620656.png
attached_assets/image_1759128672434.png
attached_assets/image_1759129009054.png
attached_assets/image_1759129020102.png
attached_assets/image_1759129355362.png
attached_assets/screenshot-1759155799095.png
attached_assets/image_1759158687921.png
attached_assets/image_1759159266227.png
attached_assets/image_1759159326673.png
attached_assets/image_1759182698662.png
attached_assets/image_1759183018100.png
attached_assets/image_1759183038003.png
attached_assets/image_1759183390773.png
attached_assets/image_1759183498569.png
attached_assets/image_1759184511257.png
attached_assets/image_1759184953911.png
attached_assets/image_1759185470323.png
attached_assets/image_1759185497504.png
attached_assets/image_1759185732615.png
attached_assets/image_1759190476822.png
attached_assets/image_1759190491540.png
attached_assets/image_1759190775961.png
attached_assets/image_1759190794141.png
attached_assets/image_1759191133016.png
attached_assets/image_1759191648857.png
attached_assets/image_1759192469801.png
attached_assets/image_1759193012836.png
attached_assets/image_1759193069407.png
attached_assets/image_1759193553140.png
attached_assets/image_1759194156293.png
attached_assets/image_1759195658536.png
attached_assets/image_1759195788890.png
attached_assets/image_1759196377971.png
attached_assets/image_1759196435303.png
attached_assets/Pasted-Great-works-nice-i-see-the-proper-servers-My-ideal-with-this-information-is-allowing-the-user-to-cl-1759199988629_1759199988631.txt
attached_assets/image_1759202709444.png
attached_assets/image_1759203862650.png
attached_assets/image_1759204924020.png
attached_assets/image_1759204935662.png
attached_assets/image_1759205839637.png
attached_assets/image_1759205851225.png
attached_assets/image_1759221199397.png
attached_assets/image_1759221572562.png
attached_assets/image_1759221617101.png
attached_assets/image_1759221674298.png
__pycache__
__pycache__/bot.cpython-311.pyc
__pycache__/email_utils.cpython-311.pyc
__pycache__/app.cpython-311.pyc
email_utils.py
templates
templates/landing.html
templates/server_settings.html
templates/dashboard.html
requirements.txt
start.py
timeclock.db
DISCORD_AUTH_REFERENCE.md
bot.py
app.py
timeclock.db-wal
timeclock.db-shm
replit.md
.replit
collect_project_snapshot_lite.sh
PROJECT_SNAPSHOT_LITE.md
```

# Key Config Files


## .replit

```
modules = ["python-3.11", "postgresql-16"]
run = "python3 bot.py"
[nix]
channel = "stable-25_05"

[workflows]
runButton = "Project"

[[workflows.workflow]]
name = "Project"
mode = "parallel"
author = "agent"

[[workflows.workflow.tasks]]
task = "workflow.run"
args = "Bot & Landing Page"

[[workflows.workflow]]
name = "Bot & Landing Page"
author = "agent"

[[workflows.workflow.tasks]]
task = "shell.exec"
args = "python start.py"
waitForPort = 5000

[workflows.workflow.metadata]
outputType = "webview"

[deployment]
deploymentTarget = "vm"
run = ["python", "start.py"]

[[ports]]
localPort = 5000
externalPort = 80

[[ports]]
localPort = 8081
externalPort = 8081

[[ports]]
localPort = 36881
externalPort = 3001

[[ports]]
localPort = 37703
externalPort = 3002

[[ports]]
localPort = 40651
externalPort = 3003

[[ports]]
localPort = 41859
externalPort = 5173

[[ports]]
localPort = 43065
externalPort = 4200

[[ports]]
localPort = 43937
externalPort = 3000

[[ports]]
localPort = 44439
externalPort = 5000

[[ports]]
localPort = 44951
externalPort = 6000

[agent]
expertMode = true
integrations = ["flask_stripe:1.0.0", "replitmail:1.0.0"]
```

## requirements.txt

```
discord.py>=2.3
tzdata
stripe
requests
urllib3
aiohttp
flask
gunicorn
werkzeug
aiohttp```

# Environment Variables (os.getenv names)

- BOT_API_PORT
- BOT_API_SECRET
- DISCORD_TOKEN
- GUILD_ID
- HEALTH_PORT
- REPL_IDENTITY
- REPLIT_DOMAINS
- REPLIT_ENVIRONMENT
- STRIPE_SECRET_KEY
- STRIPE_WEBHOOK_SECRET
- TIMECLOCK_DB
- WEB_REPL_RENEWAL

# Flask Routes (@app.route / add_url_rule)

```text
./.cache/pip/http-v2/8/c/e/2/2/8ce22e6fa22d60819e0364f8e8178ecc3fde80deba4cfd5d8e615ed9.body:65:@app.route("/")
./.cache/pip/http-v2/f/9/2/e/5/f92e55f077de42466e18a9ef3781e68abb90ed357d144ed269987f28.body:112:    @app.route('/set/')
./.cache/pip/http-v2/f/9/2/e/5/f92e55f077de42466e18a9ef3781e68abb90ed357d144ed269987f28.body:117:    @app.route('/get/')
./.local/state/replit/agent/filesystem/filesystem_state.json:1:{"file_contents":{"bot.py":{"content":"import os\nimport sqlite3\nimport csv\nimport io\nimport zipfile\nimport json\nimport threading\nimport time\nimport asyncio\nimport secrets\nimport base64\nimport requests\nfrom datetime import datetime, timezone, timedelta\nfrom typing import Optional, Dict, List\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse, parse_qsl\nimport stripe\nfrom stripe import StripeError, SignatureVerificationError\n\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\n# Import email functionality for report delivery\nfrom email_utils import send_timeclock_report_email\n\n# --- Config / Secrets ---\nTOKEN = os.getenv(\"DISCORD_TOKEN\")            # required\nDB_PATH = os.getenv(\"TIMECLOCK_DB\", \"timeclock.db\")\nGUILD_ID = os.getenv(\"GUILD_ID\")              # optional but makes commands appear instantly (guild sync)\nDEFAULT_TZ = \"America/New_York\"\nHTTP_PORT = int(os.getenv(\"HEALTH_PORT\", \"8080\"))     # Health check server port (Flask uses 5000)\n\n# --- Bot Owner Configuration ---\nBOT_OWNER_ID = 107103438139056128  # Your Discord user ID for super admin access\n\n# --- Discord Data Caching ---\n# Simple in-memory cache for Discord API data to reduce rate limiting\nDISCORD_CACHE = {\n    \"guild_roles\": {},    # guild_id -> {timestamp, data}\n    \"guild_members\": {},  # guild_id -> {timestamp, data}\n}\nCACHE_DURATION = 300  # 5 minutes cache duration\n\n# --- Stripe Configuration ---\nstripe.api_key = os.getenv(\"STRIPE_SECRET_KEY\")\nSTRIPE_WEBHOOK_SECRET = os.getenv(\"STRIPE_WEBHOOK_SECRET\")\nSTRIPE_PRICE_IDS = {\n    'basic': 'price_1SAHpL3Jrp0J9Adlfowh5qpr',   # $5/month LIVE\n    'pro': 'price_1SAHqH3Jrp0J9AdlFSJpJ32A'      # $10/month LIVE\n}\n\n# Session storage - now using database for persistence instead of in-memory dictionaries\n\n# Guild-based locks to prevent race conditions in setup operations\nguild_setup_locks: Dict[int, asyncio.Lock] = {}\n\ndef get_guild_lock(guild_id: int) -> asyncio.Lock:\n    \"\"\"Get or create an asyncio lock for a specific guild\"\"\"\n    if guild_id not in guild_setup_locks:\n        guild_setup_locks[guild_id] = asyncio.Lock()\n    return guild_setup_locks[guild_id]\n\n# --- Owner-Only Access Decorator ---\ndef owner_only(func):\n    \"\"\"Decorator to restrict commands to bot owner only\"\"\"\n    async def wrapper(interaction: discord.Interaction, *args, **kwargs):\n        if interaction.user.id != BOT_OWNER_ID:\n            # Silently ignore - command won't even be visible to non-owners\n            return\n        return await func(interaction, *args, **kwargs)\n    return wrapper\n\n# --- Proper Interaction Response Helper ---\nasync def robust_defer(interaction: discord.Interaction, ephemeral: bool = True) -> bool:\n    \"\"\"\n    Robust interaction defer with proper error handling.\n    \n    Args:\n        interaction: The Discord interaction to defer\n        ephemeral: Whether the response should be ephemeral\n    \n    Returns:\n        bool: True if defer was successful, False if interaction was already acknowledged\n    \"\"\"\n    if interaction.response.is_done():\n        print(f\"‚ö†Ô∏è Interaction already acknowledged for guild {interaction.guild_id if interaction.guild else 'Unknown'}\")\n        return False\n    \n    try:\n        await interaction.response.defer(ephemeral=ephemeral)\n        return True\n    except discord.errors.NotFound:\n        print(f\"‚ùå Interaction expired for guild {interaction.guild_id if interaction.guild else 'Unknown'}\")\n        return False\n    except discord.errors.HTTPException as e:\n        if \"already been acknowledged\" in str(e):\n            print(f\"‚ö†Ô∏è Interaction already acknowledged for guild {interaction.guild_id if interaction.guild else 'Unknown'}\")\n            return False\n        print(f\"‚ùå HTTP error during defer: {e}\")\n        return False\n\nasync def send_reply(interaction: discord.Interaction, content: Optional[str] = None, ephemeral: bool = True, **kwargs):\n    \"\"\"\n    Proper helper function to handle Discord interaction responses.\n    Uses followup if interaction is already responded to, otherwise uses initial response.\n    \n    Args:\n        interaction: The Discord interaction to respond to\n        content: Optional text content for the response (can be None if using embed= or other kwargs)\n        ephemeral: Whether the response should be ephemeral (visible only to the user)\n        **kwargs: Additional parameters like embed, view, etc.\n    \n    Returns:\n        The sent message object\n    \"\"\"\n    # Handle None content by only passing content if it's not None\n    send_kwargs = {'ephemeral': ephemeral, **kwargs}\n    if content is not None:\n        send_kwargs['content'] = content\n    \n    if interaction.response.is_done():\n        return await interaction.followup.send(**send_kwargs)\n    else:\n        await interaction.response.send_message(**send_kwargs)\n        return await interaction.original_response()\n\n# Get domain for Stripe redirects\ndef get_domain() -> str:\n    # Check if we're in production mode\n    if os.getenv('REPLIT_ENVIRONMENT') == 'production':\n        # In production, use the published domain\n        return 'on-the-clock.replit.app'\n    else:\n        # In development, use the dev domain\n        domains = os.getenv('REPLIT_DOMAINS', '')\n        return domains.split(',')[0] if domains else 'localhost:5000'\n\n\ndef create_secure_checkout_session(guild_id: int, tier: str) -> str:\n    \"\"\"Create a secure Stripe checkout session with proper validation\"\"\"\n    if not stripe.api_key:\n        raise ValueError(\"STRIPE_SECRET_KEY not configured\")\n    \n    if tier not in STRIPE_PRICE_IDS:\n        raise ValueError(f\"Invalid tier: {tier}\")\n    \n    domain = get_domain()\n    \n    try:\n        checkout_session = stripe.checkout.Session.create(\n            line_items=[{\n                'price': STRIPE_PRICE_IDS[tier],\n                'quantity': 1,\n            }],\n            mode='subscription',\n            success_url=f'https://{domain}/success?session_id={{CHECKOUT_SESSION_ID}}',\n            cancel_url=f'https://{domain}/cancel',\n            metadata={\n                'guild_id': str(guild_id),\n                'tier': tier\n            },\n            automatic_tax={'enabled': True},\n            billing_address_collection='required',\n        )\n        \n        return checkout_session.url or \"\"\n        \n    except StripeError as e:\n        raise ValueError(f\"Stripe error: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Checkout creation failed: {str(e)}\")\n\n# --- Health Check HTTP Server ---\nclass HealthCheckHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == \"/\":\n            # Serve HTML dashboard page at root\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n            self.send_header('Pragma', 'no-cache')\n            self.send_header('Expires', '0')\n            self.end_headers()\n            \n            # Get bot status info inline to avoid method issues\n            bot_instance = getattr(type(self), 'bot', None)\n            bot_status = \"üü¢ Online\" if bot_instance and bot_instance.is_ready() else \"üî¥ Offline\"\n            guild_count = len(bot_instance.guilds) if bot_instance and bot_instance.is_ready() else \"Loading...\"\n            \n            \n            # Read the functional dashboard file\n            try:\n                with open('functional_dashboard.html', 'r', encoding='utf-8') as f:\n                    dashboard_content = f.read()\n                \n                # Update the status in the dashboard\n                dashboard_content = dashboard_content.replace(\n                    'Bot Online ‚Ä¢ 127 Servers',\n                    f'Bot {bot_status} ‚Ä¢ {guild_count} Servers'\n                )\n                \n                self.wfile.write(dashboard_content.encode('utf-8'))\n                return\n                \n            except FileNotFoundError:\n                # Fallback to simple HTML if dashboard file not found\n                pass\n            \n            html_content = f\"\"\"\n            <!DOCTYPE html>\n            <html lang=\"en\">\n            <head>\n                <meta charset=\"UTF-8\">\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                <title>On the Clock - Discord Timeclock Bot</title>\n                <style>\n                    * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n                    }}\n                    body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);\n            min-height: 100vh;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: #e0e6ed;\n                    }}\n                    .container {{\n            background: #2c2f36;\n            border-radius: 20px;\n            box-shadow: 0 20px 40px rgba(0,0,0,0.4);\n            border: 1px solid #3e4147;\n            padding: 40px;\n            max-width: 800px;\n            width: 90%;\n            text-align: center;\n                    }}\n                    .header {{\n            margin-bottom: 30px;\n                    }}\n                    .bot-title {{\n            font-size: 2.5em;\n            font-weight: bold;\n            color: #5865F2;\n            margin-bottom: 10px;\n                    }}\n                    .bot-subtitle {{\n            font-size: 1.2em;\n            color: #b9bbbe;\n            margin-bottom: 20px;\n                    }}\n                    .status-grid {{\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 20px;\n            margin: 30px 0;\n                    }}\n                    .status-card {{\n            background: #36393f;\n            border-radius: 15px;\n            padding: 20px;\n            border-left: 4px solid #5865F2;\n            border: 1px solid #42464d;\n                    }}\n                    .status-title {{\n            font-weight: bold;\n            color: #dcddde;\n            margin-bottom: 8px;\n                    }}\n                    .status-value {{\n            font-size: 1.1em;\n            color: #5865F2;\n                    }}\n                    .features {{\n            text-align: left;\n            margin: 30px 0;\n            background: #36393f;\n            border-radius: 15px;\n            padding: 25px;\n            border: 1px solid #42464d;\n                    }}\n                    .features h3 {{\n            color: #5865F2;\n            margin-bottom: 15px;\n            text-align: center;\n                    }}\n                    .features ul {{\n            list-style: none;\n            color: #dcddde;\n                    }}\n                    .features li {{\n            margin: 8px 0;\n            padding-left: 25px;\n            position: relative;\n                    }}\n                    .features li:before {{\n            content: \"‚úÖ\";\n            position: absolute;\n            left: 0;\n                    }}\n                    .add-bot-btn {{\n            display: inline-block;\n            background: #5865F2;\n            color: white;\n            padding: 15px 30px;\n            border-radius: 10px;\n            text-decoration: none;\n            font-weight: bold;\n            font-size: 1.1em;\n            margin: 20px 0;\n            transition: background-color 0.3s;\n                    }}\n                    .add-bot-btn:hover {{\n            background: #4752C4;\n                    }}\n                    .beta-warning {{\n            background: #faa61a;\n            color: #2c2f36;\n            padding: 20px;\n            border-radius: 10px;\n            margin: 20px 0;\n            font-weight: bold;\n                    }}\n                    .beta-warning h3 {{\n            margin-bottom: 10px;\n                    }}\n                    .beta-warning ul {{\n            text-align: left;\n            margin: 10px 0;\n                    }}\n                    .pricing-info {{\n            background: #36393f;\n            border-radius: 15px;\n            padding: 25px;\n            margin: 20px 0;\n            border: 1px solid #42464d;\n                    }}\n                    .pricing-info h3 {{\n            color: #5865F2;\n            margin-bottom: 20px;\n                    }}\n                    .pricing-tier {{\n            background: #2c2f36;\n            padding: 15px;\n            margin: 10px 0;\n            border-radius: 8px;\n            border-left: 4px solid #5865F2;\n                    }}\n                    .free-tier {{\n            border-left-color: #faa61a;\n                    }}\n                    .pro-tier {{\n            border-left-color: #57F287;\n                    }}\n                    .footer {{\n            margin-top: 30px;\n            padding-top: 20px;\n            border-top: 1px solid #42464d;\n            color: #b9bbbe;\n            font-size: 0.9em;\n                    }}\n                </style>\n            </head>\n            <body>\n                <div class=\"container\">\n                    <div class=\"header\">\n            <div class=\"bot-title\">‚è∞ On the Clock</div>\n            <div class=\"bot-subtitle\">Professional Discord Timeclock Bot for Business Teams</div>\n                    </div>\n                    \n                    <div class=\"status-grid\">\n            <div class=\"status-card\">\n                <div class=\"status-title\">Bot Status</div>\n                <div class=\"status-value\">{bot_status}</div>\n            </div>\n            <div class=\"status-card\">\n                <div class=\"status-title\">Active Servers</div>\n                <div class=\"status-value\">{guild_count}</div>\n            </div>\n            <div class=\"status-card\">\n                <div class=\"status-title\">Last Updated</div>\n                <div class=\"status-value\">Just Now</div>\n            </div>\n                    </div>\n                    \n                    <div class=\"features\">\n            <h3>üöÄ Core Features</h3>\n            <ul>\n                <li>Easy timeclock functions with Discord buttons</li>\n                <li>Automatic timezone support with EST default</li>\n                <li>CSV timesheet reports for payroll</li>\n                <li>Multi-tier subscription system (Free/Basic/Pro)</li>\n                <li>Role-based access control</li>\n                <li>Private time entry via DMs</li>\n                <li>Automatic data retention policies</li>\n                <li>Stripe payment integration</li>\n                <li>Real-time \"On the Clock\" status display</li>\n                <li>Admin purge and cleanup commands</li>\n            </ul>\n                    </div>\n                    \n                    <div class=\"features\">\n            <h3>üéâ Version 1.1 - No More Timeout Issues!</h3>\n            <ul>\n                <li><strong>New Way:</strong> Type <code>/clock</code> to access your personal timeclock with fresh buttons</li>\n                <li><strong>Setup:</strong> Admins use <code>/setup_timeclock</code> to post instructions in channels</li>\n                <li><strong>Always Works:</strong> Fresh buttons every time - no more timeout errors!</li>\n                <li><strong>Private Interface:</strong> Only you see your timeclock responses (ephemeral)</li>\n                <li><strong>Zero Maintenance:</strong> No refresh commands needed - just works!</li>\n                <li><strong>Help:</strong> Use <code>/help</code> to see all available commands</li>\n            </ul>\n                    </div>\n                    \n                    \n                    <div class=\"beta-warning\">\n            <h3>‚ö†Ô∏è Beta Service Disclaimer</h3>\n            <p>This bot is currently in beta testing. Please be aware:</p>\n            <ul>\n                <li>üíæ Data loss is possible and backups are not guaranteed</li>\n                <li>üö´ This service may be discontinued at any time without notice</li>\n                <li>üìú No warranty or guarantee of service availability is provided</li>\n            </ul>\n            <p><strong>Use at your own risk.</strong> This bot is provided \"as-is\" without any warranties.</p>\n                    </div>\n                    \n                    <div class=\"pricing-info\">\n            <h3>üí∞ Subscription Plans</h3>\n            <div class=\"pricing-tier free-tier\">\n                <strong>Free - Testing Only</strong><br>\n                Server admin can test all features ‚Ä¢ Sample reports only ‚Ä¢ No data retention\n            </div>\n            <div class=\"pricing-tier\">\n                <strong>Basic - $5/month</strong><br>\n                Full team access ‚Ä¢ Timeclock functions ‚Ä¢ CSV Reports ‚Ä¢ 1 week data retention\n            </div>\n            <div class=\"pricing-tier pro-tier\">\n                <strong>Pro - $10/month</strong><br>\n                Everything in Basic ‚Ä¢ Extended CSV Reports ‚Ä¢ Multiple Managers ‚Ä¢ 30 days data retention\n            </div>\n                    </div>\n                    \n                    <div class=\"footer\">\n            <p>Built for businesses and teams who need reliable time tracking in Discord</p>\n            <p>Questions? Contact your server administrator</p>\n                    </div>\n                </div>\n            </body>\n            </html>\n            \"\"\"\n            self.wfile.write(html_content.encode())\n        elif self.path == \"/health\":\n            # Keep JSON health check for deployment\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            response = {\n                \"status\": \"healthy\",\n                \"service\": \"discord-bot\",\n                \"timestamp\": datetime.now(timezone.utc).isoformat()\n            }\n            self.wfile.write(json.dumps(response).encode())\n        \n        \n        elif self.path.startswith(\"/api/\"):\n            # API endpoints for dashboard data\n            self.handle_api_request()\n        \n        # Remove insecure GET checkout endpoint - checkout now done via Discord commands only\n        elif self.path.startswith(\"/success\") or self.path.startswith(\"/cancel\"):\n            # Handle payment result pages (with or without query parameters)\n            self.handle_payment_result()\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_POST(self):\n        if self.path == \"/webhook\":\n            # Handle Stripe webhooks\n            self.handle_stripe_webhook()\n        elif self.path.startswith('/api/guild/') and '/settings' in self.path:\n            # Handle guild settings updates\n            self.handle_api_settings_update()\n        elif self.path.startswith('/api/guild/') and '/admin-roles' in self.path:\n            # Handle admin role updates\n            self.handle_api_admin_roles_update()\n        elif self.path.startswith('/api/guild/') and '/employee-roles' in self.path:\n            # Handle employee role updates\n            self.handle_api_employee_roles_update()\n        elif self.path.startswith('/api/guild/') and '/recipients' in self.path:\n            # Handle recipients updates\n            self.handle_api_recipients_update()\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def handle_payment_result(self):\n        \"\"\"Handle success/cancel pages\"\"\"\n        if self.path.startswith(\"/success\"):\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html; charset=utf-8')\n            self.end_headers()\n            html = \"\"\"\n            <html>\n            <head>\n                <meta charset=\"UTF-8\">\n                <title>Payment Successful</title>\n            </head>\n            <body style=\"font-family: Arial; text-align: center; padding: 50px;\">\n                <h1>üéâ Payment Successful!</h1>\n                <p>Your Discord server subscription is now active!</p>\n                <p>Return to Discord to start using your premium features.</p>\n            </body></html>\n            \"\"\"\n            self.wfile.write(html.encode('utf-8'))\n        else:  # cancel\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            html = \"\"\"\n            <html><body style=\"font-family: Arial; text-align: center; padding: 50px;\">\n                <h1>‚ùå Payment Cancelled</h1>\n                <p>No charges were made. You can try again anytime.</p>\n                <p>Return to Discord and use the upgrade command again when ready.</p>\n            </body></html>\n            \"\"\"\n            self.wfile.write(html.encode())\n    \n    def handle_stripe_webhook(self):\n        \"\"\"Handle Stripe webhook events with proper signature verification\"\"\"\n        try:\n            if not STRIPE_WEBHOOK_SECRET:\n                print(\"‚ùå STRIPE_WEBHOOK_SECRET not configured\")\n                self.send_response(400)\n                self.end_headers()\n                return\n                \n            content_length = int(self.headers['Content-Length'])\n            payload = self.rfile.read(content_length)\n            sig_header = self.headers.get('stripe-signature')\n            \n            if not sig_header:\n                print(\"‚ùå Missing Stripe signature header\")\n                self.send_response(400)\n                self.end_headers()\n                return\n                \n            try:\n                # Verify webhook signature using Stripe\n                event = stripe.Webhook.construct_event(\n                    payload, sig_header, STRIPE_WEBHOOK_SECRET\n                )\n                \n                event_type = event.get('type')\n                print(f\"üîî Processing Stripe webhook: {event_type}\")\n                \n                if event_type == 'checkout.session.completed':\n                    session = event['data']['object']\n                    self.process_checkout_completed(session)\n                elif event_type == 'customer.subscription.updated':\n                    subscription = event['data']['object']\n                    self.handle_subscription_change(subscription)\n                elif event_type == 'customer.subscription.deleted':\n                    subscription = event['data']['object']\n                    self.handle_subscription_cancellation(subscription)\n                elif event_type == 'invoice.payment_failed':\n                    invoice = event['data']['object']\n                    self.handle_payment_failure(invoice)\n                else:\n                    print(f\"‚ÑπÔ∏è Unhandled Stripe event type: {event_type}\")\n                    \n            except ValueError as e:\n                print(f\"‚ùå Invalid webhook payload: {e}\")\n                self.send_response(400)\n                return\n            except SignatureVerificationError as e:\n                print(f\"‚ùå Invalid webhook signature: {e}\")\n                self.send_response(400)\n                return\n            except Exception as e:\n                print(f\"‚ùå Error processing webhook: {e}\")\n                import traceback\n                traceback.print_exc()\n                self.send_response(500)\n                return\n            \n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.end_headers()\n            self.wfile.write(b'{\"received\": true}')\n            \n        except Exception as e:\n            print(f\"‚ùå Webhook error: {e}\")\n            self.send_response(400)\n            self.end_headers()\n    \n    def process_checkout_completed(self, session):\n        \"\"\"Process a completed checkout session\"\"\"\n        try:\n            # Retrieve full session with line items to verify pricing\n            full_session = stripe.checkout.Session.retrieve(\n                session['id'],\n                expand=['line_items']\n            )\n            \n            # Verify the price ID matches our expected tiers\n            if full_session.line_items and full_session.line_items.data and full_session.line_items.data[0].price:\n                price_id = full_session.line_items.data[0].price.id\n                \n                tier = None\n                for t, pid in STRIPE_PRICE_IDS.items():\n                    if pid == price_id:\n                        tier = t\n                        break\n                \n                if not tier:\n                    print(f\"‚ùå Unknown price ID in checkout: {price_id}\")\n                    return\n                \n                guild_id = session.get('metadata', {}).get('guild_id')\n                \n                if guild_id:\n                    subscription_id = session.get('subscription')\n                    customer_id = session.get('customer')\n                    \n                    # Update database with verified subscription\n                    set_server_tier(int(guild_id), tier, subscription_id, customer_id)\n                    print(f\"‚úÖ Subscription activated: Guild {guild_id} -> {tier.title()}\")\n                else:\n                    print(\"‚ùå No guild_id found in session metadata\")\n            else:\n                print(\"‚ùå No line items found in checkout session\")\n                \n        except Exception as e:\n            print(f\"‚ùå Error processing checkout session: {e}\")\n            import traceback\n            traceback.print_exc()\n    \n    def handle_subscription_cancellation(self, subscription):\n        \"\"\"Handle subscription cancellation events\"\"\"\n        try:\n            # Find guild by subscription_id or customer_id\n            subscription_id = subscription.get('id')\n            customer_id = subscription.get('customer')\n            \n            if not subscription_id:\n                print(\"‚ùå No subscription ID in cancellation event\")\n                return\n                \n            with db() as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT guild_id FROM server_subscriptions \n                    WHERE subscription_id = ? OR customer_id = ?\n                \"\"\", (subscription_id, customer_id))\n                result = cursor.fetchone()\n                \n                if result:\n                    guild_id = result[0]\n                    \n                    # Update subscription status to canceled and downgrade to free\n                    conn.execute(\"\"\"\n                        UPDATE server_subscriptions \n                        SET tier = 'free', status = 'canceled'\n                        WHERE guild_id = ?\n                    \"\"\", (guild_id,))\n                    \n                    # Purge data according to free tier policy (no retention)\n                    purge_timeclock_data_only(guild_id)\n                    \n                    print(f\"‚úÖ Subscription cancelled: Guild {guild_id} downgraded to free\")\n                else:\n                    print(f\"‚ùå No guild found for subscription {subscription_id}\")\n                    \n        except Exception as e:\n            print(f\"‚ùå Error processing subscription cancellation: {e}\")\n            import traceback\n            traceback.print_exc()\n    \n    def handle_subscription_change(self, subscription):\n        \"\"\"Handle subscription change events (updates, renewals, etc.)\"\"\"\n        try:\n            subscription_id = subscription.get('id')\n            customer_id = subscription.get('customer')\n            status = subscription.get('status')\n            \n            if not subscription_id:\n                print(\"‚ùå No subscription ID in subscription change event\")\n                return\n                \n            with db() as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT guild_id FROM server_subscriptions \n                    WHERE subscription_id = ? OR customer_id = ?\n                \"\"\", (subscription_id, customer_id))\n                result = cursor.fetchone()\n                \n                if result:\n                    guild_id = result[0]\n                    \n                    # Update subscription status  \n                    if status in ['active', 'trialing', 'past_due', 'canceled', 'incomplete', 'incomplete_expired', 'unpaid']:\n                        conn.execute(\"\"\"\n                            UPDATE server_subscriptions \n                            SET status = ?\n                            WHERE guild_id = ?\n                        \"\"\", (status, guild_id))\n                        \n                        # Only downgrade and purge for truly inactive subscriptions\n                        if status in ['canceled', 'incomplete_expired', 'unpaid']:\n                            conn.execute(\"\"\"\n                                UPDATE server_subscriptions \n                                SET tier = 'free'\n                                WHERE guild_id = ?\n                            \"\"\", (guild_id,))\n                            # Purge data according to free tier policy\n                            purge_timeclock_data_only(guild_id)\n                        \n                        print(f\"‚úÖ Subscription updated: Guild {guild_id} status -> {status}\")\n                    else:\n                        print(f\"‚ö†Ô∏è Unknown subscription status: {status}\")\n                else:\n                    print(f\"‚ùå No guild found for subscription {subscription_id}\")\n                    \n        except Exception as e:\n            print(f\"‚ùå Error processing subscription change: {e}\")\n            import traceback\n            traceback.print_exc()\n    \n    def handle_payment_failure(self, invoice):\n        \"\"\"Handle payment failure events\"\"\"\n        try:\n            customer_id = invoice.get('customer')\n            subscription_id = invoice.get('subscription')\n            \n            if not customer_id and not subscription_id:\n                print(\"‚ùå No customer or subscription ID in payment failure event\")\n                return\n                \n            with db() as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT guild_id FROM server_subscriptions \n                    WHERE subscription_id = ? OR customer_id = ?\n                \"\"\", (subscription_id, customer_id))\n                result = cursor.fetchone()\n                \n                if result:\n                    guild_id = result[0]\n                    \n                    # Update subscription status to past_due\n                    conn.execute(\"\"\"\n                        UPDATE server_subscriptions \n                        SET status = 'past_due'\n                        WHERE guild_id = ?\n                    \"\"\", (guild_id,))\n                    \n                    print(f\"‚ö†Ô∏è Payment failed: Guild {guild_id} marked as past_due\")\n                    \n                    # Note: We don't immediately downgrade on payment failure\n                    # Stripe usually allows a grace period before cancellation\n                    \n                else:\n                    print(f\"‚ùå No guild found for customer {customer_id} or subscription {subscription_id}\")\n                    \n        except Exception as e:\n            print(f\"‚ùå Error processing payment failure: {e}\")\n            import traceback\n            traceback.print_exc()\n    \n    def purge_all_guild_data(self, guild_id: int):\n        \"\"\"Purge all data for a guild when subscription lapses\"\"\"\n        try:\n            with db() as conn:\n                # Set timeout for database operations\n                conn.execute(\"PRAGMA busy_timeout = 5000\")\n                \n                # Delete all sessions data\n                sessions_cursor = conn.execute(\"DELETE FROM sessions WHERE guild_id = ?\", (guild_id,))\n                sessions_deleted = sessions_cursor.rowcount\n                \n                # Delete guild settings\n                settings_cursor = conn.execute(\"DELETE FROM guild_settings WHERE guild_id = ?\", (guild_id,))\n                settings_deleted = settings_cursor.rowcount\n                \n                # Delete authorized roles\n                auth_roles_cursor = conn.execute(\"DELETE FROM authorized_roles WHERE guild_id = ?\", (guild_id,))\n                auth_roles_deleted = auth_roles_cursor.rowcount\n                \n                # Delete admin roles\n                admin_roles_cursor = conn.execute(\"DELETE FROM admin_roles WHERE guild_id = ?\", (guild_id,))\n                admin_roles_deleted = admin_roles_cursor.rowcount\n                \n                # Delete clock roles\n                employee_roles_cursor = conn.execute(\"DELETE FROM employee_roles WHERE guild_id = ?\", (guild_id,))\n                employee_roles_deleted = employee_roles_cursor.rowcount\n                \n                # Reset subscription to free tier (don't delete subscription record)\n                conn.execute(\"\"\"\n                    UPDATE server_subscriptions \n                    SET tier = 'free', subscription_id = NULL, customer_id = NULL, \n                        expires_at = NULL, status = 'cancelled'\n                    WHERE guild_id = ?\n                \"\"\", (guild_id,))\n                \n                print(f\"üóëÔ∏è Data purged for Guild {guild_id}: {sessions_deleted} sessions, {settings_deleted} settings, {auth_roles_deleted} auth roles, {admin_roles_deleted} admin roles, {employee_roles_deleted} clock roles\")\n                \n        except Exception as e:\n            print(f\"‚ùå Error purging guild data for {guild_id}: {e}\")\n            \n\n    def send_json_response(self, data, status=200):\n        \"\"\"Send JSON response\"\"\"\n        self.send_response(status)\n        self.send_header('Content-Type', 'application/json')\n        self.end_headers()\n        self.wfile.write(json.dumps(data).encode('utf-8'))\n        \n\n    def handle_api_settings_update(self):\n        \"\"\"Handle POST /api/guild/{id}/settings - Update general guild settings\"\"\"\n        try:\n            # Check session\n            session_id = self.get_session_id()\n            if not session_id:\n                self.send_json_response({'error': 'Not authenticated'}, 401)\n                return\n                \n            session = get_user_session(session_id)\n            if not session:\n                self.send_json_response({'error': 'Session expired'}, 401)\n                return\n            \n            # Extract guild ID from path\n            path_parts = self.path.split('/')\n            guild_id_str = None\n            for i, part in enumerate(path_parts):\n                if part == 'guild' and i + 1 < len(path_parts):\n                    guild_id_str = path_parts[i + 1]\n                    break\n                    \n            if not guild_id_str:\n                self.send_json_response({'error': 'Invalid URL'}, 400)\n                return\n                \n            guild_id = int(guild_id_str)\n            \n            # Check admin access\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({'error': 'Admin access required'}, 403)\n                return\n                \n            # Parse request body\n            content_length = int(self.headers.get('Content-Length', 0))\n            if content_length > 10000:  # 10KB limit\n                self.send_json_response({'error': 'Request too large'}, 400)\n                return\n                \n            post_data = self.rfile.read(content_length)\n            try:\n                data = json.loads(post_data.decode('utf-8'))\n            except json.JSONDecodeError:\n                self.send_json_response({'error': 'Invalid JSON'}, 400)\n                return\n                \n            # Update settings\n            updated_settings = {}\n            \n            if 'timezone' in data:\n                timezone = data['timezone'].strip()\n                if timezone:\n                    set_guild_setting(guild_id, 'timezone', timezone)\n                    updated_settings['timezone'] = timezone\n                    \n            if 'name_display_mode' in data:\n                mode = data['name_display_mode']\n                if mode in ['username', 'nickname']:\n                    set_guild_setting(guild_id, 'name_display_mode', mode)\n                    updated_settings['name_display_mode'] = mode\n                    \n            if 'recipient_user_id' in data:\n                recipient_id = data['recipient_user_id']\n                if recipient_id is None or (isinstance(recipient_id, str) and recipient_id.isdigit()):\n                    set_guild_setting(guild_id, 'recipient_user_id', int(recipient_id) if recipient_id else None)\n                    updated_settings['recipient_user_id'] = recipient_id\n                    \n            if 'main_admin_role_id' in data:\n                role_id = data['main_admin_role_id']\n                if role_id is None or (isinstance(role_id, str) and role_id.isdigit()):\n                    set_guild_setting(guild_id, 'main_admin_role_id', int(role_id) if role_id else None)\n                    updated_settings['main_admin_role_id'] = role_id\n                    \n            self.send_json_response({'success': True, 'updated': updated_settings})\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Settings update error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_admin_roles_update(self):\n        \"\"\"Handle POST /api/guild/{id}/admin-roles - Add/remove admin roles\"\"\"\n        try:\n            # Check session\n            session_id = self.get_session_id()\n            if not session_id:\n                self.send_json_response({'error': 'Not authenticated'}, 401)\n                return\n                \n            session = get_user_session(session_id)\n            if not session:\n                self.send_json_response({'error': 'Session expired'}, 401)\n                return\n            \n            # Extract guild ID from path\n            path_parts = self.path.split('/')\n            guild_id_str = None\n            for i, part in enumerate(path_parts):\n                if part == 'guild' and i + 1 < len(path_parts):\n                    guild_id_str = path_parts[i + 1]\n                    break\n                    \n            if not guild_id_str:\n                self.send_json_response({'error': 'Invalid URL'}, 400)\n                return\n                \n            guild_id = int(guild_id_str)\n            \n            # Check admin access\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({'error': 'Admin access required'}, 403)\n                return\n                \n            # Parse request body\n            content_length = int(self.headers.get('Content-Length', 0))\n            post_data = self.rfile.read(content_length)\n            try:\n                data = json.loads(post_data.decode('utf-8'))\n            except json.JSONDecodeError:\n                self.send_json_response({'error': 'Invalid JSON'}, 400)\n                return\n                \n            action = data.get('action')  # 'add' or 'remove'\n            role_id = data.get('role_id')\n            \n            if not action or not role_id or action not in ['add', 'remove']:\n                self.send_json_response({'error': 'Invalid request'}, 400)\n                return\n                \n            try:\n                role_id = int(role_id)\n            except ValueError:\n                self.send_json_response({'error': 'Invalid role ID'}, 400)\n                return\n                \n            if action == 'add':\n                add_admin_role(guild_id, role_id)\n            else:\n                remove_admin_role(guild_id, role_id)\n                \n            self.send_json_response({'success': True, 'action': action, 'role_id': str(role_id)})\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Admin roles update error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_employee_roles_update(self):\n        \"\"\"Handle POST /api/guild/{id}/employee-roles - Add/remove employee roles\"\"\"\n        try:\n            # Check session\n            session_id = self.get_session_id()\n            if not session_id:\n                self.send_json_response({'error': 'Not authenticated'}, 401)\n                return\n                \n            session = get_user_session(session_id)\n            if not session:\n                self.send_json_response({'error': 'Session expired'}, 401)\n                return\n            \n            # Extract guild ID from path\n            path_parts = self.path.split('/')\n            guild_id_str = None\n            for i, part in enumerate(path_parts):\n                if part == 'guild' and i + 1 < len(path_parts):\n                    guild_id_str = path_parts[i + 1]\n                    break\n                    \n            if not guild_id_str:\n                self.send_json_response({'error': 'Invalid URL'}, 400)\n                return\n                \n            guild_id = int(guild_id_str)\n            \n            # Check admin access\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({'error': 'Admin access required'}, 403)\n                return\n                \n            # Parse request body\n            content_length = int(self.headers.get('Content-Length', 0))\n            post_data = self.rfile.read(content_length)\n            try:\n                data = json.loads(post_data.decode('utf-8'))\n            except json.JSONDecodeError:\n                self.send_json_response({'error': 'Invalid JSON'}, 400)\n                return\n                \n            action = data.get('action')  # 'add' or 'remove'\n            role_id = data.get('role_id')\n            \n            if not action or not role_id or action not in ['add', 'remove']:\n                self.send_json_response({'error': 'Invalid request'}, 400)\n                return\n                \n            try:\n                role_id = int(role_id)\n            except ValueError:\n                self.send_json_response({'error': 'Invalid role ID'}, 400)\n                return\n                \n            if action == 'add':\n                add_employee_role(guild_id, role_id)\n            else:\n                remove_employee_role(guild_id, role_id)\n                \n            self.send_json_response({'success': True, 'action': action, 'role_id': str(role_id)})\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Employee roles update error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_guild_roles(self, session: Dict, guild_id_str: str):\n        \"\"\"Handle GET /api/guild/{id}/roles - Get available Discord roles for the guild\"\"\"\n        try:\n            guild_id = int(guild_id_str)\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({\"error\": \"Admin access required\"}, 403)\n                return\n                \n            # Check cache first\n            cached_roles = get_cached_discord_data(\"guild_roles\", guild_id)\n            if cached_roles:\n                self.send_json_response({\"roles\": cached_roles})\n                return\n\n            # Get bot guild data\n            bot_instance = getattr(type(self), 'bot', None)\n            if not bot_instance or not bot_instance.is_ready():\n                self.send_json_response({\"error\": \"Bot not ready\"}, 503)\n                return\n                \n            bot_guild = bot_instance.get_guild(guild_id)\n            if not bot_guild:\n                self.send_json_response({\"error\": \"Guild not found\"}, 404)\n                return\n                \n            # Get all roles (excluding @everyone)\n            roles = []\n            for role in bot_guild.roles:\n                if role.name != \"@everyone\":\n                    roles.append({\n                        \"id\": str(role.id),\n                        \"name\": role.name,\n                        \"color\": role.color.value,\n                        \"position\": role.position,\n                        \"mentionable\": role.mentionable,\n                        \"hoist\": role.hoist,\n                        \"managed\": role.managed\n                    })\n                    \n            # Sort by position (higher position = higher in hierarchy)\n            roles.sort(key=lambda r: r[\"position\"], reverse=True)\n            \n            # Cache the results for better performance\n            set_cached_discord_data(\"guild_roles\", guild_id, roles)\n            \n            self.send_json_response({\"roles\": roles})\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Guild roles API error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_guild_member(self, session: Dict, guild_id_str: str):\n        \"\"\"Handle GET /api/guild/{id}/member - Get user's guild member data including current roles\"\"\"\n        try:\n            guild_id = int(guild_id_str)\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild:\n                self.send_json_response({\"error\": \"Guild access required\"}, 403)\n                return\n                \n            # Get user's Discord guild member data using OAuth access token\n            access_token = session.get('access_token')\n            if not access_token:\n                self.send_json_response({\"error\": \"Access token not found\"}, 401)\n                return\n                \n            member_data = get_discord_guild_member(access_token, guild_id_str)\n            if not member_data:\n                self.send_json_response({\"error\": \"Unable to fetch guild member data\"}, 500)\n                return\n                \n            # Get bot guild data to fetch role details\n            bot_instance = getattr(type(self), 'bot', None)\n            if not bot_instance or not bot_instance.is_ready():\n                self.send_json_response({\"error\": \"Bot not ready\"}, 503)\n                return\n                \n            bot_guild = bot_instance.get_guild(guild_id)\n            if not bot_guild:\n                self.send_json_response({\"error\": \"Guild not found\"}, 404)\n                return\n                \n            # Get role details for user's roles\n            user_roles = []\n            user_role_ids = member_data.get('roles', [])\n            \n            for role_id in user_role_ids:\n                bot_role = bot_guild.get_role(int(role_id))\n                if bot_role and bot_role.name != \"@everyone\":\n                    user_roles.append({\n                        \"id\": str(bot_role.id),\n                        \"name\": bot_role.name,\n                        \"color\": bot_role.color.value,\n                        \"position\": bot_role.position,\n                        \"mentionable\": bot_role.mentionable,\n                        \"hoist\": bot_role.hoist,\n                        \"managed\": bot_role.managed,\n                        \"permissions\": str(bot_role.permissions.value)\n                    })\n            \n            # Sort by position (higher position = higher in hierarchy)\n            user_roles.sort(key=lambda r: r[\"position\"], reverse=True)\n            \n            # Check if user has admin or employee access using unified OAuth-based logic\n            has_admin_access = self.is_dashboard_admin(session, guild_id)\n            \n            # For employee access, check clock roles using OAuth member data\n            has_employee_access = has_admin_access  # Admins always have employee access\n            \n            if not has_admin_access:\n                # Check if user has specific employee/clock roles using existing member_data\n                user_role_ids = [int(role_id) for role_id in member_data.get('roles', [])]\n                \n                # Check clock roles from database\n                employee_roles = get_employee_roles(guild_id)\n                \n                # If no clock roles configured, fall back to admin-only access\n                if not employee_roles:\n                    has_employee_access = has_admin_access\n                else:\n                    has_employee_access = any(role_id in user_role_ids for role_id in employee_roles)\n            \n            response_data = {\n                \"user\": {\n                    \"id\": member_data.get('user', {}).get('id'),\n                    \"username\": member_data.get('user', {}).get('username'),\n                    \"avatar\": member_data.get('user', {}).get('avatar'),\n                    \"nick\": member_data.get('nick')\n                },\n                \"roles\": user_roles,\n                \"joined_at\": member_data.get('joined_at'),\n                \"premium_since\": member_data.get('premium_since'),\n                \"timeclock_access\": {\n                    \"admin\": has_admin_access,\n                    \"employee\": has_employee_access\n                }\n            }\n            \n            self.send_json_response(response_data)\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Guild member API error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_guild_members(self, session: Dict, guild_id_str: str):\n        \"\"\"Handle GET /api/guild/{id}/members?query=... - Search guild members for recipients\"\"\"\n        try:\n            guild_id = int(guild_id_str)\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({\"error\": \"Admin access required\"}, 403)\n                return\n                \n            # Get bot guild data\n            bot_instance = getattr(type(self), 'bot', None)\n            if not bot_instance or not bot_instance.is_ready():\n                self.send_json_response({\"error\": \"Bot not ready\"}, 503)\n                return\n                \n            bot_guild = bot_instance.get_guild(guild_id)\n            if not bot_guild:\n                self.send_json_response({\"error\": \"Guild not found\"}, 404)\n                return\n            \n            # Parse query parameters for search\n            from urllib.parse import urlparse, parse_qs\n            parsed_url = urlparse(self.path)\n            query_params = parse_qs(parsed_url.query)\n            \n            search_query = query_params.get('query', [''])[0].lower().strip()\n            limit = min(int(query_params.get('limit', ['50'])[0]), 100)  # Max 100 members\n            \n            # Check cache first (only for full member lists without search)\n            if not search_query:\n                cached_members = get_cached_discord_data(\"guild_members\", guild_id)\n                if cached_members:\n                    # Apply limit to cached data\n                    limited_members = cached_members[:limit]\n                    # Return same API contract as non-cached path\n                    self.send_json_response({\n                        \"members\": limited_members,\n                        \"total_shown\": len(limited_members),\n                        \"has_more\": len(cached_members) > limit,\n                        \"query\": \"\"\n                    })\n                    return\n            \n            # Get guild members (limited to first 1000 due to Discord API limitations without special intents)\n            members = []\n            member_count = 0\n            \n            for member in bot_guild.members:\n                if member_count >= limit:\n                    break\n                    \n                # Skip bots unless specifically searching for them\n                if member.bot and 'bot' not in search_query:\n                    continue\n                \n                # Filter by search query if provided\n                if search_query:\n                    search_targets = [\n                        member.display_name.lower(),\n                        member.name.lower(),\n                        str(member.id)\n                    ]\n                    if member.nick:\n                        search_targets.append(member.nick.lower())\n                        \n                    if not any(search_query in target for target in search_targets):\n                        continue\n                \n                # Add member to results\n                members.append({\n                    \"id\": str(member.id),\n                    \"username\": member.name,\n                    \"display_name\": member.display_name,\n                    \"avatar\": member.avatar.url if member.avatar else None,\n                    \"bot\": member.bot,\n                    \"nick\": member.nick,\n                    \"joined_at\": member.joined_at.isoformat() if member.joined_at else None\n                })\n                member_count += 1\n                \n            # Cache the results for better performance (only for full member lists without search)\n            if not search_query:\n                set_cached_discord_data(\"guild_members\", guild_id, members)\n                \n            self.send_json_response({\n                \"members\": members,\n                \"total_shown\": len(members),\n                \"has_more\": member_count >= limit,\n                \"query\": search_query\n            })\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Guild members API error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_get_guild_settings(self, session: Dict, guild_id_str: str):\n        \"\"\"Handle GET /api/guild/{id}/settings - Get current guild settings\"\"\"\n        try:\n            guild_id = int(guild_id_str)\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({\"error\": \"Admin access required\"}, 403)\n                return\n                \n            # Get current guild settings\n            settings = {\n                \"timezone\": get_guild_setting(guild_id, \"timezone\") or \"UTC\",\n                \"name_display_mode\": get_guild_setting(guild_id, \"name_display_mode\") or \"username\", \n                \"recipient_user_id\": get_guild_setting(guild_id, \"recipient_user_id\"),\n                \"main_admin_role_id\": get_guild_setting(guild_id, \"main_admin_role_id\"),\n                \"subscription_tier\": get_server_tier(guild_id),\n                \"admin_roles\": get_admin_roles(guild_id),\n                \"employee_roles\": get_employee_roles(guild_id)\n            }\n            \n            self.send_json_response({\"settings\": settings})\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Guild settings API error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_get_admin_roles(self, session, guild_id_str):\n        \"\"\"Handle GET /api/guild/{id}/admin-roles - Get current admin roles\"\"\"\n        try:\n            guild_id = int(guild_id_str)\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({\"error\": \"Admin access required\"}, 403)\n                return\n                \n            # Get bot guild data\n            bot_instance = getattr(type(self), 'bot', None)\n            if not bot_instance or not bot_instance.is_ready():\n                self.send_json_response({\"error\": \"Bot not ready\"}, 503)\n                return\n                \n            bot_guild = bot_instance.get_guild(guild_id)\n            if not bot_guild:\n                self.send_json_response({\"error\": \"Guild not found\"}, 404)\n                return\n                \n            # Get configured admin roles\n            admin_role_ids = get_admin_roles(guild_id)\n            admin_roles = []\n            \n            for role_id in admin_role_ids:\n                role = bot_guild.get_role(role_id)\n                if role:\n                    admin_roles.append({\n                        \"id\": str(role.id),\n                        \"name\": role.name,\n                        \"color\": role.color.value,\n                        \"position\": role.position,\n                        \"mentionable\": role.mentionable,\n                        \"hoist\": role.hoist,\n                        \"managed\": role.managed\n                    })\n                else:\n                    # Role was deleted, keep the ID for cleanup reference\n                    admin_roles.append({\n                        \"id\": str(role_id),\n                        \"name\": f\"<Deleted Role: {role_id}>\",\n                        \"color\": 0,\n                        \"position\": 0,\n                        \"mentionable\": False,\n                        \"hoist\": False,\n                        \"managed\": False,\n                        \"deleted\": True\n                    })\n                    \n            # Sort by position (higher position = higher in hierarchy)\n            admin_roles.sort(key=lambda r: r[\"position\"], reverse=True)\n            \n            self.send_json_response({\"admin_roles\": admin_roles})\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Get admin roles API error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_get_employee_roles(self, session, guild_id_str):\n        \"\"\"Handle GET /api/guild/{id}/employee-roles - Get current employee roles\"\"\"\n        try:\n            guild_id = int(guild_id_str)\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild or not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({\"error\": \"Admin access required\"}, 403)\n                return\n                \n            # Get bot guild data\n            bot_instance = getattr(type(self), 'bot', None)\n            if not bot_instance or not bot_instance.is_ready():\n                self.send_json_response({\"error\": \"Bot not ready\"}, 503)\n                return\n                \n            bot_guild = bot_instance.get_guild(guild_id)\n            if not bot_guild:\n                self.send_json_response({\"error\": \"Guild not found\"}, 404)\n                return\n                \n            # Get configured employee roles\n            employee_role_ids = get_employee_roles(guild_id)\n            employee_roles = []\n            \n            for role_id in employee_role_ids:\n                role = bot_guild.get_role(role_id)\n                if role:\n                    employee_roles.append({\n                        \"id\": str(role.id),\n                        \"name\": role.name,\n                        \"color\": role.color.value,\n                        \"position\": role.position,\n                        \"mentionable\": role.mentionable,\n                        \"hoist\": role.hoist,\n                        \"managed\": role.managed\n                    })\n                else:\n                    # Role was deleted, keep the ID for cleanup reference\n                    employee_roles.append({\n                        \"id\": str(role_id),\n                        \"name\": f\"<Deleted Role: {role_id}>\",\n                        \"color\": 0,\n                        \"position\": 0,\n                        \"mentionable\": False,\n                        \"hoist\": False,\n                        \"managed\": False,\n                        \"deleted\": True\n                    })\n                    \n            # Sort by position (higher position = higher in hierarchy)\n            employee_roles.sort(key=lambda r: r[\"position\"], reverse=True)\n            \n            self.send_json_response({\"employee_roles\": employee_roles})\n            \n        except ValueError:\n            self.send_json_response({'error': 'Invalid guild ID'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Get employee roles API error: {e}\")\n            self.send_json_response({'error': 'Server error'}, 500)\n\n    def handle_api_get_recipients(self, session, guild_id_str):\n        \"\"\"Handle GET /api/guild/{id}/recipients - Get current report recipients\"\"\"\n        try:\n            # Validate guild ID format\n            try:\n                guild_id = int(guild_id_str)\n            except ValueError:\n                self.send_json_response({'error': 'Invalid guild ID format'}, 400)\n                return\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild:\n                self.send_json_response({'error': 'Access denied: Guild not found in user permissions'}, 403)\n                return\n            \n            # CRITICAL: Check admin permissions for this specific guild\n            if not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({'error': 'Insufficient permissions: Admin access required for recipients management'}, 403)\n                return\n            \n            # Get all recipients\n            recipients = get_report_recipients(guild_id)\n            \n            # Format recipients for frontend\n            discord_recipients = []\n            email_recipients = []\n            \n            for recipient_row in recipients:\n                recipient_id, recipient_type, discord_user_id, email_address, created_at = recipient_row\n                \n                if recipient_type == 'discord' and discord_user_id:\n                    try:\n                        # Try to get user info - fallback to ID if not found\n                        bot_instance = getattr(type(self), 'bot', None)\n                        if bot_instance:\n                            user = bot_instance.get_user(int(discord_user_id))\n                            if user:\n                                discord_recipients.append({\n                                    'id': recipient_id,\n                                    'user_id': discord_user_id,\n                                    'username': user.name,\n                                    'display_name': user.display_name or user.name,\n                                    'avatar': user.avatar.url if user.avatar else None\n                                })\n                                continue\n                        \n                        # Fallback for unknown users\n                        discord_recipients.append({\n                            'id': recipient_id,\n                            'user_id': discord_user_id,\n                            'username': f'Unknown User ({discord_user_id})',\n                            'display_name': f'Unknown User ({discord_user_id})',\n                            'avatar': None\n                        })\n                    except Exception:\n                        discord_recipients.append({\n                            'id': recipient_id,\n                            'user_id': discord_user_id,\n                            'username': f'Unknown User ({discord_user_id})',\n                            'display_name': f'Unknown User ({discord_user_id})',\n                            'avatar': None\n                        })\n                \n                elif recipient_type == 'email' and email_address:\n                    email_recipients.append({\n                        'id': recipient_id,\n                        'email': email_address\n                    })\n            \n            self.send_json_response({\n                'discord_recipients': discord_recipients,\n                'email_recipients': email_recipients\n            })\n            \n        except Exception as e:\n            print(f\"‚ùå Error in handle_api_get_recipients: {e}\")\n            self.send_json_response({\"error\": \"Server error\"}, 500)\n\n    def handle_api_recipients_update(self):\n        \"\"\"Handle POST /api/guild/{id}/recipients - Add/remove recipients\"\"\"\n        try:\n            # Check session\n            session_id = self.get_session_id()\n            if not session_id:\n                self.send_json_response({'error': 'Not authenticated'}, 401)\n                return\n                \n            session = get_user_session(session_id)\n            if not session:\n                self.send_json_response({'error': 'Session expired'}, 401)\n                return\n            \n            # Parse guild ID from path\n            path_parts = self.path.split('/')\n            if len(path_parts) < 4:\n                self.send_json_response({'error': 'Invalid path'}, 400)\n                return\n                \n            guild_id_str = path_parts[3]\n            try:\n                guild_id = int(guild_id_str)\n            except ValueError:\n                self.send_json_response({'error': 'Invalid guild ID'}, 400)\n                return\n            \n            # Check if user has access to this guild\n            user_guild = None\n            for ug in session.get('guilds', []):\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild:\n                self.send_json_response({'error': 'Guild not found'}, 404)\n                return\n            \n            # Check admin permissions\n            if not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({'error': 'Admin access required'}, 403)\n                return\n            \n            # Parse request body\n            content_length = int(self.headers.get('Content-Length', 0))\n            if content_length == 0:\n                self.send_json_response({'error': 'Empty request body'}, 400)\n                return\n                \n            post_data = self.rfile.read(content_length).decode('utf-8')\n            data = json.loads(post_data)\n            \n            action = data.get('action')  # 'add' or 'remove'\n            recipient_type = data.get('recipient_type')  # 'discord' or 'email'\n            \n            if action not in ['add', 'remove']:\n                self.send_json_response({'error': 'Invalid action'}, 400)\n                return\n                \n            if recipient_type not in ['discord', 'email']:\n                self.send_json_response({'error': 'Invalid recipient type'}, 400)\n                return\n            \n            if action == 'add':\n                if recipient_type == 'discord':\n                    user_id = data.get('user_id')\n                    if not user_id:\n                        self.send_json_response({'error': 'user_id required for discord recipients'}, 400)\n                        return\n                    \n                    # Validate Discord user ID format (should be numeric string)\n                    try:\n                        discord_user_id = int(user_id)\n                        if discord_user_id <= 0:\n                            self.send_json_response({'error': 'Invalid Discord user ID: must be positive integer'}, 400)\n                            return\n                    except (ValueError, TypeError):\n                        self.send_json_response({'error': 'Invalid Discord user ID format: must be numeric'}, 400)\n                        return\n                    \n                    success = add_report_recipient(guild_id, 'discord', str(discord_user_id), None)\n                    if success:\n                        self.send_json_response({'message': 'Discord recipient added successfully'})\n                    else:\n                        self.send_json_response({'error': 'Recipient already exists for this guild'}, 409)\n                        \n                elif recipient_type == 'email':\n                    email = data.get('email')\n                    if not email:\n                        self.send_json_response({'error': 'email required for email recipients'}, 400)\n                        return\n                    \n                    # Basic email validation (RFC-like check)\n                    if not isinstance(email, str) or '@' not in email or len(email) < 5 or len(email) > 254:\n                        self.send_json_response({'error': 'Invalid email format'}, 400)\n                        return\n                    \n                    # Additional email format checks\n                    email_parts = email.split('@')\n                    if len(email_parts) != 2 or not email_parts[0] or not email_parts[1] or '.' not in email_parts[1]:\n                        self.send_json_response({'error': 'Invalid email format: must contain valid local and domain parts'}, 400)\n                        return\n                    \n                    success = add_report_recipient(guild_id, 'email', None, email.lower().strip())\n                    if success:\n                        self.send_json_response({'message': 'Email recipient added successfully'})\n                    else:\n                        self.send_json_response({'error': 'Email recipient already exists for this guild'}, 409)\n            \n            elif action == 'remove':\n                if recipient_type == 'discord':\n                    user_id = data.get('user_id')\n                    if not user_id:\n                        self.send_json_response({'error': 'user_id required for Discord recipient removal'}, 400)\n                        return\n                    \n                    # Validate Discord user ID format for removal\n                    try:\n                        discord_user_id = int(user_id)\n                        if discord_user_id <= 0:\n                            self.send_json_response({'error': 'Invalid Discord user ID for removal'}, 400)\n                            return\n                    except (ValueError, TypeError):\n                        self.send_json_response({'error': 'Invalid Discord user ID format for removal'}, 400)\n                        return\n                    \n                    remove_report_recipient(guild_id, 'discord', str(discord_user_id), None)\n                    \n                elif recipient_type == 'email':\n                    email = data.get('email')\n                    if not email:\n                        self.send_json_response({'error': 'email required for email recipient removal'}, 400)\n                        return\n                    \n                    # Basic validation for email removal\n                    if not isinstance(email, str) or '@' not in email:\n                        self.send_json_response({'error': 'Invalid email format for removal'}, 400)\n                        return\n                    \n                    remove_report_recipient(guild_id, 'email', None, email.lower().strip())\n                \n                self.send_json_response({'message': 'Recipient removed successfully'})\n                \n        except json.JSONDecodeError:\n            self.send_json_response({'error': 'Invalid JSON'}, 400)\n        except Exception as e:\n            print(f\"‚ùå Error in handle_api_recipients_update: {e}\")\n            self.send_json_response({\"error\": \"Server error\"}, 500)\n\n    def handle_api_request(self):\n        \"\"\"Handle API requests for dashboard data\"\"\"\n        try:\n            # Check session\n            session_id = self.get_session_id()\n            if not session_id:\n                self.send_json_response({\"error\": \"Not authenticated\"}, 401)\n                return\n                \n            session = get_user_session(session_id)\n            if not session:\n                self.send_json_response({\"error\": \"Session expired\"}, 401)\n                return\n            \n            # Route API endpoints\n            if self.path == \"/api/user\":\n                self.handle_api_user(session)\n            elif self.path == \"/api/logout\":\n                self.handle_api_logout(session)\n            elif self.path.startswith(\"/api/guild/\"):\n                # Parse guild-specific endpoints\n                path_parts = self.path.split(\"/\")\n                if len(path_parts) >= 4:\n                    guild_id = path_parts[3]\n                    \n                    if len(path_parts) == 4:\n                        # /api/guild/{id}\n                        self.handle_api_guild(session, guild_id)\n                    elif len(path_parts) == 5:\n                        endpoint = path_parts[4]\n                        if endpoint == \"roles\":\n                            # /api/guild/{id}/roles\n                            self.handle_api_guild_roles(session, guild_id)\n                        elif endpoint == \"member\":\n                            # /api/guild/{id}/member\n                            self.handle_api_guild_member(session, guild_id)\n                        elif endpoint == \"recipients\":\n                            # /api/guild/{id}/recipients\n                            self.handle_api_get_recipients(session, guild_id)\n                        elif endpoint == \"members\":\n                            # /api/guild/{id}/members\n                            self.handle_api_guild_members(session, guild_id)\n                        elif endpoint == \"settings\":\n                            # /api/guild/{id}/settings\n                            self.handle_api_get_guild_settings(session, guild_id)\n                        else:\n                            self.send_json_response({\"error\": \"Endpoint not found\"}, 404)\n                    else:\n                        self.send_json_response({\"error\": \"Invalid API path\"}, 400)\n                else:\n                    self.send_json_response({\"error\": \"Invalid API path\"}, 400)\n            else:\n                self.send_json_response({\"error\": \"Endpoint not found\"}, 404)\n                \n        except Exception as e:\n            print(f\"‚ùå API request error: {e}\")\n            self.send_json_response({\"error\": \"Internal server error\"}, 500)\n\n    def handle_api_user(self, session: Dict):\n        \"\"\"Handle /api/user endpoint\"\"\"\n        user_data = {\n            \"id\": session['user_id'],\n            \"username\": session['username'],\n            \"discriminator\": session['discriminator'],\n            \"avatar\": session['avatar'],\n            \"guilds\": []\n        }\n        \n        # Filter guilds to only include ones where the bot is present AND user has admin access\n        bot_instance = getattr(type(self), 'bot', None)\n        if bot_instance and bot_instance.is_ready():\n            bot_guilds = {guild.id: guild for guild in bot_instance.guilds}\n            \n            for user_guild in session.get('guilds', []):\n                guild_id = int(user_guild['id'])\n                if guild_id in bot_guilds:\n                    # Only include guilds where user has admin access\n                    if self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                        bot_guild = bot_guilds[guild_id]\n                        user_data['guilds'].append({\n                            \"id\": str(guild_id),\n                            \"name\": user_guild['name'],\n                            \"icon\": user_guild.get('icon'),\n                            \"owner\": user_guild.get('owner', False),\n                            \"permissions\": user_guild.get('permissions', '0'),\n                            \"member_count\": bot_guild.member_count,\n                            \"tier\": get_server_tier(guild_id)\n                        })\n        \n        self.send_json_response(user_data)\n\n    def handle_api_logout(self, session: Dict):\n        \"\"\"Handle /api/logout endpoint - Clear session and logout user\"\"\"\n        try:\n            session_id = self.get_session_id()\n            \n            # Delete the user session from database\n            if session_id:\n                delete_success = delete_user_session(session_id)\n                print(f\"üîÑ Logout: Session deletion {'successful' if delete_success else 'failed'} for user {session.get('username', 'unknown')}\")\n            \n            # Clear the session cookie\n            self.send_response(200)\n            self.send_header('Content-Type', 'application/json')\n            \n            # Clear session cookies (both current and legacy)\n            self.send_header('Set-Cookie', 'otc_session=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=0')\n            self.send_header('Set-Cookie', 'session=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=0')\n            \n            # Add cache control headers to prevent caching\n            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n            self.send_header('Pragma', 'no-cache')\n            self.send_header('Expires', '0')\n            \n            # Add Clear-Site-Data header for thorough cleanup\n            self.send_header('Clear-Site-Data', '\"cache\", \"cookies\", \"storage\"')\n            \n            self.end_headers()\n            \n            response_data = {\n                \"success\": True,\n                \"message\": \"Logged out successfully\",\n                \"redirect\": \"/\"\n            }\n            \n            self.wfile.write(json.dumps(response_data).encode('utf-8'))\n            \n        except Exception as e:\n            print(f\"‚ùå Logout error: {e}\")\n            self.send_json_response({\"error\": \"Logout failed\"}, 500)\n\n    def handle_api_guild(self, session: Dict, guild_id_str: str):\n        \"\"\"Handle /api/guild/{id} endpoint\"\"\"\n        try:\n            guild_id = int(guild_id_str)\n            \n            # Check if user has access to this guild\n            user_guilds = session.get('guilds', [])\n            user_guild = None\n            for ug in user_guilds:\n                if ug['id'] == guild_id_str:\n                    user_guild = ug\n                    break\n                    \n            if not user_guild:\n                self.send_json_response({\"error\": \"Access denied\"}, 403)\n                return\n                \n            # Check if user has admin permissions in this guild\n            if not self.user_has_dashboard_admin_access(session['user_id'], guild_id, user_guild):\n                self.send_json_response({\"error\": \"Admin access required\"}, 403)\n                return\n                \n            # Get bot guild data\n            bot_instance = getattr(type(self), 'bot', None)\n            if not bot_instance or not bot_instance.is_ready():\n                self.send_json_response({\"error\": \"Bot not ready\"}, 503)\n                return\n                \n            bot_guild = bot_instance.get_guild(guild_id)\n            if not bot_guild:\n                self.send_json_response({\"error\": \"Guild not found\"}, 404)\n                return\n                \n            # Get server data\n            tier = get_server_tier(guild_id)\n            retention_days = get_retention_days(guild_id)\n            \n            # Count currently clocked in users\n            with db() as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT COUNT(*) FROM sessions \n                    WHERE guild_id = ? AND clock_out IS NULL\n                \"\"\", (guild_id,))\n                clocked_in_count = cursor.fetchone()[0]\n                \n            # Get admin and employee roles\n            admin_roles = []\n            employee_roles = []\n            \n            with db() as conn:\n                # Get admin roles\n                cursor = conn.execute(\"SELECT role_id FROM admin_roles WHERE guild_id = ?\", (guild_id,))\n                admin_role_ids = [row[0] for row in cursor.fetchall()]\n                \n                # Get employee roles  \n                cursor = conn.execute(\"SELECT role_id FROM employee_roles WHERE guild_id = ?\", (guild_id,))\n                employee_role_ids = [row[0] for row in cursor.fetchall()]\n                \n            # Get role names from Discord\n            for role_id in admin_role_ids:\n                role = bot_guild.get_role(role_id)\n                if role:\n                    admin_roles.append({\"id\": str(role_id), \"name\": role.name})\n                    \n            for role_id in employee_role_ids:\n                role = bot_guild.get_role(role_id)\n                if role:\n                    employee_roles.append({\"id\": str(role_id), \"name\": role.name})\n            \n            guild_data = {\n                \"id\": str(guild_id),\n                \"name\": bot_guild.name,\n                \"icon\": str(bot_guild.icon) if bot_guild.icon else None,\n                \"member_count\": bot_guild.member_count,\n                \"online_count\": sum(1 for member in bot_guild.members if member.status != discord.Status.offline),\n                \"tier\": tier,\n                \"retention_days\": retention_days,\n                \"clocked_in_count\": clocked_in_count,\n                \"admin_roles\": admin_roles,\n                \"employee_roles\": employee_roles\n            }\n            \n            self.send_json_response(guild_data)\n            \n        except ValueError:\n            self.send_json_response({\"error\": \"Invalid guild ID\"}, 400)\n        except Exception as e:\n            print(f\"‚ùå Guild API error: {e}\")\n            self.send_json_response({\"error\": \"Server error\"}, 500)\n\n    \n    def log_message(self, format, *args):\n        # Suppress default HTTP server logs to avoid cluttering Discord bot logs\n        pass\n\n\ndef purge_guild_data_for_testing(guild_id: int):\n    \"\"\"Standalone function to purge guild data for testing purposes\"\"\"\n    try:\n        with db() as conn:\n            # Set timeout for database operations\n            conn.execute(\"PRAGMA busy_timeout = 5000\")\n            \n            # Delete all sessions data\n            sessions_cursor = conn.execute(\"DELETE FROM sessions WHERE guild_id = ?\", (guild_id,))\n            sessions_deleted = sessions_cursor.rowcount\n            \n            # Delete guild settings\n            settings_cursor = conn.execute(\"DELETE FROM guild_settings WHERE guild_id = ?\", (guild_id,))\n            settings_deleted = settings_cursor.rowcount\n            \n            # Delete authorized roles\n            auth_roles_cursor = conn.execute(\"DELETE FROM authorized_roles WHERE guild_id = ?\", (guild_id,))\n            auth_roles_deleted = auth_roles_cursor.rowcount\n            \n            # Delete admin roles\n            admin_roles_cursor = conn.execute(\"DELETE FROM admin_roles WHERE guild_id = ?\", (guild_id,))\n            admin_roles_deleted = admin_roles_cursor.rowcount\n            \n            # Delete clock roles\n            employee_roles_cursor = conn.execute(\"DELETE FROM employee_roles WHERE guild_id = ?\", (guild_id,))\n            employee_roles_deleted = employee_roles_cursor.rowcount\n            \n            # Reset subscription to free tier (don't delete subscription record)\n            conn.execute(\"\"\"\n                UPDATE server_subscriptions \n                SET tier = 'free', subscription_id = NULL, customer_id = NULL, \n                    expires_at = NULL, status = 'cancelled'\n                WHERE guild_id = ?\n            \"\"\", (guild_id,))\n            \n            print(f\"üóëÔ∏è Data purged for Guild {guild_id}: {sessions_deleted} sessions, {settings_deleted} settings, {auth_roles_deleted} auth roles, {admin_roles_deleted} admin roles, {employee_roles_deleted} clock roles\")\n            return sessions_deleted + settings_deleted + auth_roles_deleted + admin_roles_deleted + employee_roles_deleted\n            \n    except Exception as e:\n        print(f\"‚ùå Error purging guild data for {guild_id}: {e}\")\n        raise\n    \n    def do_HEAD(self):\n        if self.path == \"/\" or self.path == \"/health\":\n            self.send_response(200)\n            if self.path == \"/\":\n                self.send_header('Content-type', 'text/html')\n            else:\n                self.send_header('Content-type', 'application/json')\n            self.end_headers()\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def handle_subscription_change(self, subscription):\n        \"\"\"Handle subscription status changes\"\"\"\n        try:\n            # Find guild by customer_id or subscription_id\n            with db() as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT guild_id FROM server_subscriptions \n                    WHERE subscription_id = ? OR customer_id = ?\n                \"\"\", (subscription['id'], subscription['customer']))\n                result = cursor.fetchone()\n                \n                if result:\n                    guild_id = result[0]\n                    status = subscription['status']\n                    current_period_end = subscription['current_period_end']\n                    \n                    # Update subscription status\n                    conn.execute(\"\"\"\n                        UPDATE server_subscriptions \n                        SET status = ?, expires_at = ?\n                        WHERE guild_id = ?\n                    \"\"\", (status, datetime.fromtimestamp(current_period_end, timezone.utc).isoformat(), guild_id))\n                    \n                    print(f\"üîÑ Subscription updated: Guild {guild_id} -> {status}\")\n                    \n        except Exception as e:\n            print(f\"‚ùå Error handling subscription change: {e}\")\n    \n    def handle_payment_failure(self, invoice):\n        \"\"\"Handle failed payments\"\"\"\n        try:\n            customer_id = invoice['customer']\n            \n            with db() as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT guild_id FROM server_subscriptions \n                    WHERE customer_id = ?\n                \"\"\", (customer_id,))\n                result = cursor.fetchone()\n                \n                if result:\n                    guild_id = result[0]\n                    \n                    # Mark as past_due but don't downgrade immediately\n                    conn.execute(\"\"\"\n                        UPDATE server_subscriptions \n                        SET status = 'past_due'\n                        WHERE guild_id = ?\n                    \"\"\", (guild_id,))\n                    \n                    print(f\"‚ö†Ô∏è Payment failed: Guild {guild_id} marked as past_due\")\n                    \n        except Exception as e:\n            print(f\"‚ùå Error handling payment failure: {e}\")\n\n    def handle_oauth_login(self):\n        \"\"\"Handle OAuth login initiation\"\"\"\n        try:\n            # Generate state parameter for security\n            state = secrets.token_urlsafe(32)\n            \n            # Store state in database instead of memory\n            if not create_oauth_session(state, self.client_address[0], expiry_minutes=15):\n                self.send_response(500)\n                self.send_header('Content-type', 'text/html')\n                self.end_headers()\n                self.wfile.write(b\"<h1>OAuth Error</h1><p>Failed to create session</p>\")\n                return\n            \n            # Generate Discord OAuth URL\n            oauth_url = get_discord_oauth_url(state)\n            \n            # Redirect to Discord OAuth\n            self.send_response(302)\n            self.send_header('Location', oauth_url)\n            self.end_headers()\n            \n            print(f\"üîó OAuth login initiated from {self.client_address[0]} with state: {state[:8]}...\")\n            \n        except Exception as e:\n            print(f\"‚ùå OAuth login error: {e}\")\n            self.send_response(500)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b\"<h1>OAuth Error</h1><p>Failed to initiate login</p>\")\n\n\n    def send_oauth_error(self, message: str):\n        \"\"\"Send OAuth error page\"\"\"\n        self.send_response(400)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n        \n        html = f\"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>Authentication Error</title>\n            <style>\n                body {{ font-family: Arial; text-align: center; padding: 50px; background: #1a1a2e; color: white; }}\n                .error {{ background: rgba(255,107,107,0.1); padding: 20px; border-radius: 10px; border: 1px solid #ff6b6b; }}\n            </style>\n        </head>\n        <body>\n            <div class=\"error\">\n                <h1>üîí Authentication Error</h1>\n                <p>{message}</p>\n                <p><a href=\"/\" style=\"color: #5865F2;\">Return to Dashboard</a></p>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        self.wfile.write(html.encode('utf-8'))\n\n\ndef start_health_server():\n    \"\"\"Start the health check HTTP server in a separate thread\"\"\"\n    # Pass bot reference to handler to fix LSP error\n    setattr(HealthCheckHandler, 'bot', bot)\n    httpd = HTTPServer(('0.0.0.0', HTTP_PORT), HealthCheckHandler)\n    print(f\"üîß Health check server starting on http://0.0.0.0:{HTTP_PORT}\")\n    httpd.serve_forever()\n\ndef db():\n    conn = sqlite3.connect(DB_PATH)\n    conn.execute(\"PRAGMA foreign_keys = ON\")\n    conn.execute(\"PRAGMA journal_mode = WAL\")  # Write-Ahead Logging for better concurrency\n    conn.execute(\"PRAGMA busy_timeout = 5000\")  # 5 second timeout globally\n    conn.execute(\"PRAGMA synchronous = NORMAL\")  # Balance between safety and performance\n    return conn\n\ndef run_migrations():\n    \"\"\"Run database migrations with exclusive locking before any other operations\"\"\"\n    import time\n    import random\n    \n    max_retries = 5\n    for attempt in range(max_retries):\n        try:\n            with db() as conn:\n                # Begin exclusive transaction\n                conn.execute(\"BEGIN IMMEDIATE\")\n                \n                # Check if customer_id column exists\n                cursor = conn.execute(\"PRAGMA table_info(server_subscriptions)\")\n                columns = {row[1] for row in cursor.fetchall()}\n                \n                if 'customer_id' not in columns:\n                    print(\"üîß Adding missing customer_id column to server_subscriptions table...\")\n                    conn.execute(\"ALTER TABLE server_subscriptions ADD COLUMN customer_id TEXT\")\n                    print(\"‚úÖ Migration completed: customer_id column added\")\n                else:\n                    print(\"‚úÖ Migration check: customer_id column already exists\")\n                \n                conn.commit()\n                return True\n                \n        except sqlite3.OperationalError as e:\n            if \"locked\" in str(e).lower() and attempt < max_retries - 1:\n                wait_time = (2 ** attempt) + random.uniform(0, 1)\n                print(f\"‚è≥ Database locked on migration attempt {attempt + 1}, retrying in {wait_time:.1f}s...\")\n                time.sleep(wait_time)\n                continue\n            else:\n                print(f\"‚ùå Migration failed after {attempt + 1} attempts: {e}\")\n                raise\n        except Exception as e:\n            print(f\"‚ùå Migration error: {e}\")\n            raise\n    \n    return False\n\ndef init_db():\n    with db() as conn:\n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS guild_settings (\n            guild_id INTEGER PRIMARY KEY,\n            recipient_user_id INTEGER,\n            button_channel_id INTEGER,\n            button_message_id INTEGER,\n            timezone TEXT DEFAULT 'America/New_York',\n            name_display_mode TEXT DEFAULT 'username'\n        )\n        \"\"\")\n        \n        # Add name_display_mode column if it doesn't exist (for existing databases)\n        try:\n            conn.execute(\"ALTER TABLE guild_settings ADD COLUMN name_display_mode TEXT DEFAULT 'username'\")\n        except:\n            pass  # Column already exists\n        \n        # Migration 1: Convert role_id from INTEGER to TEXT for Discord snowflakes\n        # Run BEFORE table creation to migrate existing data\n        try:\n            cursor = conn.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='admin_roles'\")\n            if cursor.fetchone():\n                # Table exists, check if it needs migration\n                cursor = conn.execute(\"PRAGMA table_info(admin_roles)\")\n                columns = cursor.fetchall()\n                role_id_col = next((col for col in columns if col[1] == 'role_id'), None)\n                if role_id_col and 'INTEGER' in role_id_col[2].upper():\n                    print(\"üîß Migrating admin_roles: Converting role_id from INTEGER to TEXT...\")\n                    conn.execute(\"\"\"\n                    CREATE TABLE admin_roles_new (\n                        guild_id TEXT,\n                        role_id TEXT,\n                        PRIMARY KEY (guild_id, role_id)\n                    )\n                    \"\"\")\n                    conn.execute(\"\"\"\n                    INSERT INTO admin_roles_new (guild_id, role_id)\n                    SELECT CAST(guild_id AS TEXT), CAST(role_id AS TEXT) FROM admin_roles\n                    \"\"\")\n                    conn.execute(\"DROP TABLE admin_roles\")\n                    conn.execute(\"ALTER TABLE admin_roles_new RENAME TO admin_roles\")\n                    print(\"‚úÖ admin_roles migration completed\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è admin_roles migration skipped or failed: {e}\")\n        \n        try:\n            cursor = conn.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='employee_roles'\")\n            if cursor.fetchone():\n                # Table exists, check if it needs migration\n                cursor = conn.execute(\"PRAGMA table_info(employee_roles)\")\n                columns = cursor.fetchall()\n                role_id_col = next((col for col in columns if col[1] == 'role_id'), None)\n                if role_id_col and 'INTEGER' in role_id_col[2].upper():\n                    print(\"üîß Migrating employee_roles: Converting role_id from INTEGER to TEXT...\")\n                    conn.execute(\"\"\"\n                    CREATE TABLE employee_roles_new (\n                        guild_id TEXT,\n                        role_id TEXT,\n                        PRIMARY KEY (guild_id, role_id)\n                    )\n                    \"\"\")\n                    conn.execute(\"\"\"\n                    INSERT INTO employee_roles_new (guild_id, role_id)\n                    SELECT CAST(guild_id AS TEXT), CAST(role_id AS TEXT) FROM employee_roles\n                    \"\"\")\n                    conn.execute(\"DROP TABLE employee_roles\")\n                    conn.execute(\"ALTER TABLE employee_roles_new RENAME TO employee_roles\")\n                    print(\"‚úÖ employee_roles migration completed\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è employee_roles migration skipped or failed: {e}\")\n        \n        # Migration 2: Convert main_admin_role_id from INTEGER to TEXT\n        try:\n            cursor = conn.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='guild_settings'\")\n            if cursor.fetchone():\n                cursor = conn.execute(\"PRAGMA table_info(guild_settings)\")\n                columns = cursor.fetchall()\n                main_admin_col = next((col for col in columns if col[1] == 'main_admin_role_id'), None)\n                if main_admin_col and 'INTEGER' in main_admin_col[2].upper():\n                    print(\"üîß Migrating guild_settings: Converting main_admin_role_id from INTEGER to TEXT...\")\n                    conn.execute(\"ALTER TABLE guild_settings ADD COLUMN main_admin_role_id_new TEXT\")\n                    conn.execute(\"UPDATE guild_settings SET main_admin_role_id_new = CAST(main_admin_role_id AS TEXT) WHERE main_admin_role_id IS NOT NULL\")\n                    conn.execute(\"\"\"\n                    CREATE TABLE guild_settings_new (\n                        guild_id INTEGER PRIMARY KEY,\n                        recipient_user_id INTEGER,\n                        button_channel_id INTEGER,\n                        button_message_id INTEGER,\n                        timezone TEXT DEFAULT 'America/New_York',\n                        name_display_mode TEXT DEFAULT 'username',\n                        main_admin_role_id TEXT\n                    )\n                    \"\"\")\n                    conn.execute(\"\"\"\n                    INSERT INTO guild_settings_new \n                    SELECT guild_id, recipient_user_id, button_channel_id, button_message_id, \n                           timezone, name_display_mode, main_admin_role_id_new \n                    FROM guild_settings\n                    \"\"\")\n                    conn.execute(\"DROP TABLE guild_settings\")\n                    conn.execute(\"ALTER TABLE guild_settings_new RENAME TO guild_settings\")\n                    print(\"‚úÖ guild_settings.main_admin_role_id migration completed\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è guild_settings migration skipped or failed: {e}\")\n        \n        # Add main_admin_role_id column if it doesn't exist (for main admin role feature)\n        try:\n            conn.execute(\"ALTER TABLE guild_settings ADD COLUMN main_admin_role_id TEXT\")\n        except:\n            pass  # Column already exists\n        \n        # Now create tables if they don't exist (with correct TEXT types)\n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS authorized_roles (\n            guild_id TEXT,\n            role_id TEXT,\n            PRIMARY KEY (guild_id, role_id)\n        )\n        \"\"\")\n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS admin_roles (\n            guild_id TEXT,\n            role_id TEXT,\n            PRIMARY KEY (guild_id, role_id)\n        )\n        \"\"\")\n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS employee_roles (\n            guild_id TEXT,\n            role_id TEXT,\n            PRIMARY KEY (guild_id, role_id)\n        )\n        \"\"\")\n        \n        try:\n            cursor = conn.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='clock_roles'\")\n            if cursor.fetchone():\n                conn.execute(\"INSERT OR IGNORE INTO employee_roles (guild_id, role_id) SELECT CAST(guild_id AS TEXT), CAST(role_id AS TEXT) FROM clock_roles\")\n                conn.execute(\"DROP TABLE clock_roles\")\n        except:\n            pass\n        \n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS sessions (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            guild_id INTEGER NOT NULL,\n            user_id INTEGER NOT NULL,\n            clock_in TEXT NOT NULL,     -- ISO UTC\n            clock_out TEXT,             -- ISO UTC\n            duration_seconds INTEGER\n        )\n        \"\"\")\n        \n        # Add indexes for performance\n        conn.execute(\"\"\"\n        CREATE INDEX IF NOT EXISTS idx_sessions_guild_clock_out \n        ON sessions(guild_id, clock_out)\n        \"\"\")\n        conn.execute(\"\"\"\n        CREATE INDEX IF NOT EXISTS idx_sessions_guild_user_clock_out \n        ON sessions(guild_id, user_id, clock_out)\n        \"\"\")\n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS server_subscriptions (\n            guild_id INTEGER PRIMARY KEY,\n            tier TEXT NOT NULL DEFAULT 'free',\n            subscription_id TEXT,\n            customer_id TEXT,\n            expires_at TEXT,\n            status TEXT DEFAULT 'active'\n        )\n        \"\"\")\n        \n        # Recipients table for multiple report recipients per guild\n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS report_recipients (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            guild_id INTEGER NOT NULL,\n            recipient_type TEXT NOT NULL CHECK(recipient_type IN ('discord', 'email')),\n            recipient_id TEXT,  -- Discord user ID for 'discord' type\n            email_address TEXT, -- Email address for 'email' type\n            created_at TEXT NOT NULL DEFAULT (datetime('now')),\n            FOREIGN KEY (guild_id) REFERENCES guild_settings (guild_id),\n            UNIQUE(guild_id, recipient_type, recipient_id),\n            UNIQUE(guild_id, recipient_type, email_address)\n        )\n        \"\"\")\n        \n        # Index for performance\n        conn.execute(\"\"\"\n        CREATE INDEX IF NOT EXISTS idx_report_recipients_guild \n        ON report_recipients(guild_id)\n        \"\"\")\n        \n        # Bot guilds table to track which servers the bot is connected to\n        conn.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS bot_guilds (\n            guild_id TEXT PRIMARY KEY,\n            guild_name TEXT,\n            joined_at TEXT NOT NULL\n        )\n        \"\"\")\n\n\n\n# --- Subscription/Tier Management ---\ndef get_server_tier(guild_id: int) -> str:\n    \"\"\"Get subscription tier for a server (free/basic/pro)\"\"\"\n    with db() as conn:\n        cursor = conn.execute(\n            \"SELECT tier, status FROM server_subscriptions WHERE guild_id = ?\",\n            (guild_id,)\n        )\n        result = cursor.fetchone()\n        if not result:\n            return \"free\"\n        \n        tier, status = result\n        # If subscription is canceled, treat as free tier\n        if status == \"canceled\":\n            return \"free\"\n        \n        return tier\n\ndef set_server_tier(guild_id: int, tier: str, subscription_id: Optional[str] = None, customer_id: Optional[str] = None):\n    \"\"\"Set subscription tier for a server\"\"\"\n    with db() as conn:\n        if subscription_id and customer_id:\n            # Full subscription with customer info\n            conn.execute(\"\"\"\n                INSERT OR REPLACE INTO server_subscriptions \n                (guild_id, tier, subscription_id, expires_at, status, customer_id) \n                VALUES (?, ?, ?, NULL, 'active', ?)\n            \"\"\", (guild_id, tier, subscription_id, customer_id))\n        elif subscription_id:\n            # Subscription without customer (legacy)\n            conn.execute(\"\"\"\n                INSERT OR REPLACE INTO server_subscriptions \n                (guild_id, tier, subscription_id, expires_at, status) \n                VALUES (?, ?, ?, NULL, 'active')\n            \"\"\", (guild_id, tier, subscription_id))\n        else:\n            # Free tier or manual assignment\n            conn.execute(\"\"\"\n                INSERT OR REPLACE INTO server_subscriptions \n                (guild_id, tier, expires_at, status) \n                VALUES (?, ?, NULL, 'active')\n            \"\"\", (guild_id, tier))\n\ndef check_tier_access(guild_id: int, required_tier: str) -> bool:\n    \"\"\"Check if server has access to features requiring a specific tier\"\"\"\n    tier_hierarchy = {'free': 0, 'basic': 1, 'pro': 2}\n    current_tier = get_server_tier(guild_id)\n    return tier_hierarchy.get(current_tier, 0) >= tier_hierarchy.get(required_tier, 0)\n\ndef is_server_admin(user: discord.Member) -> bool:\n    \"\"\"Check if user is server administrator (for free tier restrictions)\"\"\"\n    return user.guild_permissions.administrator\n\n# --- Data Retention Management ---\ndef get_retention_days(guild_id: int) -> int:\n    \"\"\"Get data retention days based on subscription tier\"\"\"\n    tier = get_server_tier(guild_id)\n    retention_policy = {\n        'free': 0,       # No retention - test only\n        'basic': 7,      # 1 week  \n        'pro': 30        # 1 month (30 days)\n    }\n    return retention_policy.get(tier, 0)\n\ndef cleanup_old_sessions(guild_id: Optional[int] = None) -> int:\n    \"\"\"Clean up old session data based on retention policy. Returns count of deleted records.\"\"\"\n    deleted_count = 0\n    max_retries = 3\n    \n    for attempt in range(max_retries):\n        try:\n            with db() as conn:\n                \n                if guild_id:\n                    # Clean up specific guild - only delete COMPLETED sessions older than retention period\n                    retention_days = get_retention_days(guild_id)\n                    cutoff_date = datetime.now(timezone.utc) - timedelta(days=retention_days)\n                    \n                    cursor = conn.execute(\"\"\"\n                        DELETE FROM sessions \n                        WHERE guild_id = ? AND clock_out IS NOT NULL AND clock_out < ?\n                    \"\"\", (guild_id, cutoff_date.isoformat()))\n                    deleted_count = cursor.rowcount\n                else:\n                    # Clean up all guilds based on their individual retention policies\n                    guilds_cursor = conn.execute(\"SELECT DISTINCT guild_id FROM sessions\")\n                    guild_ids = [row[0] for row in guilds_cursor.fetchall()]\n                    \n                    for guild_id in guild_ids:\n                        if guild_id is None:\n                            continue  # Skip invalid guild IDs\n                        retention_days = get_retention_days(guild_id)\n                        cutoff_date = datetime.now(timezone.utc) - timedelta(days=retention_days)\n                        \n                        cursor = conn.execute(\"\"\"\n                            DELETE FROM sessions \n                            WHERE guild_id = ? AND clock_out IS NOT NULL AND clock_out < ?\n                        \"\"\", (guild_id, cutoff_date.isoformat()))\n                        deleted_count += cursor.rowcount\n                \n                # Optimize database after cleanup (only if we deleted something)\n                if deleted_count > 0:\n                    conn.execute(\"PRAGMA wal_checkpoint\")\n                    # Skip VACUUM in background cleanup to avoid long locks\n                    \n            # Success - exit retry loop\n            break\n            \n        except sqlite3.OperationalError as e:\n            if \"database is locked\" in str(e) and attempt < max_retries - 1:\n                print(f\"üîÑ Database locked, retrying cleanup attempt {attempt + 1}/{max_retries}\")\n                time.sleep(2 ** attempt)  # Exponential backoff: 1s, 2s, 4s\n                continue\n            else:\n                raise\n    \n    return deleted_count\n\ndef cleanup_user_sessions(guild_id: int, user_id: int) -> int:\n    \"\"\"Delete all timeclock sessions for a specific user in a guild. Returns count of deleted records.\"\"\"\n    deleted_count = 0\n    max_retries = 3\n    \n    for attempt in range(max_retries):\n        try:\n            with db() as conn:\n                # Set timeout for database operations\n                conn.execute(\"PRAGMA busy_timeout = 5000\")\n                \n                # Delete all sessions for the specific user in this guild\n                cursor = conn.execute(\"\"\"\n                    DELETE FROM sessions \n                    WHERE guild_id = ? AND user_id = ?\n                \"\"\", (guild_id, user_id))\n                deleted_count = cursor.rowcount\n                \n                # Optimize database after cleanup (only if we deleted something)\n                if deleted_count > 0:\n                    conn.execute(\"PRAGMA wal_checkpoint\")\n                    \n            # Success - exit retry loop\n            break\n            \n        except sqlite3.OperationalError as e:\n            if \"database is locked\" in str(e) and attempt < max_retries - 1:\n                print(f\"üîÑ Database locked, retrying user cleanup attempt {attempt + 1}/{max_retries}\")\n                time.sleep(2 ** attempt)  # Exponential backoff: 1s, 2s, 4s\n                continue\n            else:\n                raise\n    \n    return deleted_count\n\ndef get_guild_setting(guild_id: int, key: str, default=None):\n    # Map of allowed keys to their SQL column queries\n    column_queries = {\n        'recipient_user_id': \"SELECT recipient_user_id FROM guild_settings WHERE guild_id=?\",\n        'timezone': \"SELECT timezone FROM guild_settings WHERE guild_id=?\",\n        'name_display_mode': \"SELECT name_display_mode FROM guild_settings WHERE guild_id=?\",\n        'main_admin_role_id': \"SELECT main_admin_role_id FROM guild_settings WHERE guild_id=?\"\n    }\n    \n    if key not in column_queries:\n        raise ValueError(f\"Invalid column name: {key}\")\n    \n    with db() as conn:\n        cur = conn.execute(column_queries[key], (guild_id,))\n        row = cur.fetchone()\n        return row[0] if row and row[0] is not None else default\n\n# --- Report Recipients Management ---\n\ndef add_report_recipient(guild_id: int, recipient_type: str, recipient_id: Optional[str] = None, email_address: Optional[str] = None):\n    \"\"\"Add a report recipient for a guild\"\"\"\n    if recipient_type not in ['discord', 'email']:\n        raise ValueError(\"recipient_type must be 'discord' or 'email'\")\n    \n    if recipient_type == 'discord' and not recipient_id:\n        raise ValueError(\"recipient_id is required for discord type\")\n    \n    if recipient_type == 'email' and not email_address:\n        raise ValueError(\"email_address is required for email type\")\n    \n    try:\n        with db() as conn:\n            conn.execute(\"\"\"\n                INSERT INTO report_recipients (guild_id, recipient_type, recipient_id, email_address)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (guild_id, recipient_type, recipient_id, email_address))\n            return True\n    except sqlite3.IntegrityError:\n        # Recipient already exists\n        return False\n\ndef remove_report_recipient(guild_id: int, recipient_type: str, recipient_id: Optional[str] = None, email_address: Optional[str] = None):\n    \"\"\"Remove a report recipient for a guild\"\"\"\n    with db() as conn:\n        if recipient_type == 'discord':\n            conn.execute(\"\"\"\n                DELETE FROM report_recipients \n                WHERE guild_id = ? AND recipient_type = ? AND recipient_id = ?\n            \"\"\", (guild_id, recipient_type, recipient_id))\n        else:  # email\n            conn.execute(\"\"\"\n                DELETE FROM report_recipients \n                WHERE guild_id = ? AND recipient_type = ? AND email_address = ?\n            \"\"\", (guild_id, recipient_type, email_address))\n\ndef get_report_recipients(guild_id: int, recipient_type: Optional[str] = None):\n    \"\"\"Get all report recipients for a guild, optionally filtered by type\"\"\"\n    with db() as conn:\n        if recipient_type:\n            cursor = conn.execute(\"\"\"\n                SELECT id, recipient_type, recipient_id, email_address, created_at\n                FROM report_recipients \n                WHERE guild_id = ? AND recipient_type = ?\n                ORDER BY created_at ASC\n            \"\"\", (guild_id, recipient_type))\n        else:\n            cursor = conn.execute(\"\"\"\n                SELECT id, recipient_type, recipient_id, email_address, created_at\n                FROM report_recipients \n                WHERE guild_id = ?\n                ORDER BY recipient_type, created_at ASC\n            \"\"\", (guild_id,))\n        \n        return cursor.fetchall()\n\nasync def send_timeclock_notifications(guild_id: int, interaction: discord.Interaction, start_dt: datetime, end_dt: datetime, elapsed: int, tz_name: str):\n    \"\"\"Send timeclock notifications to all configured recipients\"\"\"\n    # Get all recipients for this guild\n    all_recipients = get_report_recipients(guild_id)\n    \n    # Also check for legacy single recipient\n    legacy_recipient_id = get_guild_setting(guild_id, \"recipient_user_id\")\n    \n    # Prepare the notification embed\n    embed = discord.Embed(\n        title=\"Timeclock Entry\",\n        description=f\"**Employee:** {interaction.user.mention} (`{interaction.user.id}`)\",\n        color=discord.Color.blurple(),\n        timestamp=end_dt\n    )\n    embed.add_field(name=\"Clock In\", value=fmt(start_dt, tz_name), inline=True)\n    embed.add_field(name=\"Clock Out\", value=fmt(end_dt, tz_name), inline=True)\n    embed.add_field(name=\"Total\", value=human_duration(elapsed), inline=False)\n    guild_name = interaction.guild.name if interaction.guild else \"Unknown Server\"\n    embed.set_footer(text=f\"Guild: {guild_name} ‚Ä¢ ID: {guild_id}\")\n    \n    notification_sent = False\n    errors = []\n    \n    # Send to new recipients system\n    for recipient_row in all_recipients:\n        recipient_id, recipient_type, discord_user_id, email_address, created_at = recipient_row\n        \n        if recipient_type == 'discord' and discord_user_id:\n            try:\n                user = await bot.fetch_user(int(discord_user_id))\n                await user.send(embed=embed)\n                notification_sent = True\n            except discord.Forbidden:\n                errors.append(f\"Discord user {discord_user_id} has DMs disabled\")\n            except discord.NotFound:\n                errors.append(f\"Discord user {discord_user_id} not found\")\n            except Exception as e:\n                errors.append(f\"Failed to notify Discord user {discord_user_id}: {str(e)}\")\n        \n        elif recipient_type == 'email' and email_address:\n            try:\n                # Send email notification\n                guild_name = interaction.guild.name if interaction.guild else \"Unknown Server\"\n                # In guild interactions, user is always a Member\n                user_name = get_user_display_name(interaction.user, guild_id)  # type: ignore[arg-type]\n                \n                # Create plain text email content\n                email_text = f\"\"\"\nTimeclock Entry Notification\n\nEmployee: {user_name} (ID: {interaction.user.id})\nServer: {guild_name}\n\nClock In: {fmt(start_dt, tz_name)}\nClock Out: {fmt(end_dt, tz_name)}\nTotal Duration: {human_duration(elapsed)}\n\nTimestamp: {end_dt.strftime('%Y-%m-%d %H:%M:%S')} UTC\n\"\"\".strip()\n                \n                # Send email using our email utility\n                from email_utils import send_email\n                result = await send_email(\n                    to=email_address,\n                    subject=f\"Timeclock Entry - {user_name} ({guild_name})\",\n                    text=email_text\n                )\n                \n                notification_sent = True\n                print(f\"‚úÖ Email notification sent to {email_address}\")\n                \n            except Exception as e:\n                errors.append(f\"Failed to send email to {email_address}: {str(e)}\")\n                print(f\"‚ùå Email notification failed for {email_address}: {str(e)}\")\n    \n    # Fallback to legacy recipient if no new recipients configured\n    if not all_recipients and legacy_recipient_id:\n        try:\n            manager = await bot.fetch_user(legacy_recipient_id)\n            await manager.send(embed=embed)\n            notification_sent = True\n        except discord.Forbidden:\n            errors.append(\"Legacy recipient has DMs disabled\")\n        except discord.NotFound:\n            errors.append(\"Legacy recipient not found\")\n        except Exception as e:\n            errors.append(f\"Failed to notify legacy recipient: {str(e)}\")\n    \n    # Report any errors to the user\n    if errors and not notification_sent:\n        try:\n            await interaction.followup.send(\n                \"‚ö†Ô∏è Could not send notifications to any recipients:\\n\" + \"\\n\".join(f\"‚Ä¢ {error}\" for error in errors[:3]),\n                ephemeral=True\n            )\n        except Exception:\n            pass\n    elif errors:\n        try:\n            await interaction.followup.send(\n                f\"‚ö†Ô∏è Some notifications failed:\\n\" + \"\\n\".join(f\"‚Ä¢ {error}\" for error in errors[:3]),\n                ephemeral=True\n            )\n        except Exception:\n            pass\n\ndef set_guild_setting(guild_id: int, key: str, value):\n    # Map of allowed keys to their SQL update queries\n    update_queries = {\n        'recipient_user_id': \"UPDATE guild_settings SET recipient_user_id=? WHERE guild_id=?\",\n        'timezone': \"UPDATE guild_settings SET timezone=? WHERE guild_id=?\",\n        'name_display_mode': \"UPDATE guild_settings SET name_display_mode=? WHERE guild_id=?\",\n        'main_admin_role_id': \"UPDATE guild_settings SET main_admin_role_id=? WHERE guild_id=?\"\n    }\n    \n    if key not in update_queries:\n        raise ValueError(f\"Invalid column name: {key}\")\n    \n    with db() as conn:\n        conn.execute(\"INSERT OR IGNORE INTO guild_settings(guild_id) VALUES (?)\", (guild_id,))\n        conn.execute(update_queries[key], (value, guild_id))\n\ndef get_user_display_name(user: discord.Member, guild_id: int) -> str:\n    \"\"\"Get user display name based on guild preference: 'username' or 'nickname'\"\"\"\n    display_mode = get_guild_setting(guild_id, \"name_display_mode\", \"username\")\n    \n    if display_mode == \"nickname\" and hasattr(user, 'display_name'):\n        return user.display_name\n    else:\n        return user.name\n\ndef get_active_session(guild_id: int, user_id: int):\n    with db() as conn:\n        cur = conn.execute(\"\"\"\n            SELECT id, clock_in FROM sessions\n            WHERE guild_id=? AND user_id=? AND clock_out IS NULL\n            ORDER BY id DESC LIMIT 1\n        \"\"\", (guild_id, user_id))\n        return cur.fetchone()\n\ndef start_session(guild_id: int, user_id: int, clock_in_iso: str):\n    with db() as conn:\n        conn.execute(\"\"\"\n            INSERT INTO sessions (guild_id, user_id, clock_in)\n            VALUES (?, ?, ?)\n        \"\"\", (guild_id, user_id, clock_in_iso))\n\ndef close_session(session_id: int, clock_out_iso: str, duration_s: int):\n    with db() as conn:\n        conn.execute(\"\"\"\n            UPDATE sessions SET clock_out=?, duration_seconds=? WHERE id=?\n        \"\"\", (clock_out_iso, duration_s, session_id))\n\ndef get_sessions_report(guild_id: int, user_id: Optional[int], start_utc: str, end_utc: str):\n    \"\"\"Get sessions for report generation within date range (UTC boundaries).\"\"\"\n    with db() as conn:\n        if user_id is not None:\n            # Report for specific user\n            cur = conn.execute(\"\"\"\n                SELECT user_id, clock_in, clock_out, duration_seconds\n                FROM sessions\n                WHERE guild_id=? AND user_id=? \n                AND clock_out IS NOT NULL\n                AND clock_in < ?\n                AND clock_out >= ?\n                ORDER BY clock_in\n            \"\"\", (guild_id, user_id, end_utc, start_utc))\n        else:\n            # Report for all users\n            cur = conn.execute(\"\"\"\n                SELECT user_id, clock_in, clock_out, duration_seconds\n                FROM sessions\n                WHERE guild_id=? \n                AND clock_out IS NOT NULL\n                AND clock_in < ?\n                AND clock_out >= ?\n                ORDER BY user_id, clock_in\n            \"\"\", (guild_id, end_utc, start_utc))\n        return cur.fetchall()\n\n\n\ndef add_admin_role(guild_id: int, role_id: int):\n    \"\"\"Add a role as admin for Reports/Upgrade button access.\"\"\"\n    with db() as conn:\n        # Convert IDs to strings for database storage (Discord snowflakes)\n        conn.execute(\"INSERT OR IGNORE INTO admin_roles (guild_id, role_id) VALUES (?, ?)\", \n                     (str(guild_id), str(role_id)))\n\ndef remove_admin_role(guild_id: int, role_id: int):\n    \"\"\"Remove a role from admin Reports/Upgrade button access.\"\"\"\n    with db() as conn:\n        # Convert IDs to strings for database storage (Discord snowflakes)\n        conn.execute(\"DELETE FROM admin_roles WHERE guild_id=? AND role_id=?\", \n                     (str(guild_id), str(role_id)))\n\ndef get_admin_roles(guild_id: int):\n    \"\"\"Get all admin role IDs for a guild. Returns integers for Discord.py compatibility.\"\"\"\n    with db() as conn:\n        cur = conn.execute(\"SELECT role_id FROM admin_roles WHERE guild_id=?\", (str(guild_id),))\n        # Convert back to int for Discord.py (role.id is an int)\n        return [int(row[0]) for row in cur.fetchall()]\n\ndef user_has_admin_access(user: discord.Member):\n    \"\"\"Check if user has admin access (Discord admin OR custom admin role OR main admin role).\"\"\"\n    # Check Discord administrator permission first\n    if user.guild_permissions.administrator:\n        return True\n    \n    user_role_ids = [role.id for role in user.roles]\n    \n    # Check main admin role (primary designated admin role)\n    main_admin_role_id = get_guild_setting(user.guild.id, \"main_admin_role_id\")\n    if main_admin_role_id:\n        # Convert to int for comparison with Discord.py role IDs\n        try:\n            if int(main_admin_role_id) in user_role_ids:\n                return True\n        except (ValueError, TypeError):\n            pass\n    \n    # Check custom admin roles (additional admin roles) - already returns ints\n    admin_roles = get_admin_roles(user.guild.id)\n    return any(role_id in user_role_ids for role_id in admin_roles)\n\ndef add_employee_role(guild_id: int, role_id: int):\n    \"\"\"Add a role that can use timeclock functions.\"\"\"\n    with db() as conn:\n        # Convert IDs to strings for database storage (Discord snowflakes)\n        conn.execute(\"INSERT OR IGNORE INTO employee_roles (guild_id, role_id) VALUES (?, ?)\", \n                     (str(guild_id), str(role_id)))\n\ndef remove_employee_role(guild_id: int, role_id: int):\n    \"\"\"Remove a role from timeclock functions access.\"\"\"\n    with db() as conn:\n        # Convert IDs to strings for database storage (Discord snowflakes)\n        conn.execute(\"DELETE FROM employee_roles WHERE guild_id=? AND role_id=?\", \n                     (str(guild_id), str(role_id)))\n\ndef get_employee_roles(guild_id: int):\n    \"\"\"Get all clock role IDs for a guild. Returns integers for Discord.py compatibility.\"\"\"\n    with db() as conn:\n        cur = conn.execute(\"SELECT role_id FROM employee_roles WHERE guild_id=?\", (str(guild_id),))\n        # Convert back to int for Discord.py (role.id is an int)\n        return [int(row[0]) for row in cur.fetchall()]\n\ndef user_has_clock_access(user: discord.Member, server_tier: str):\n    \"\"\"Check if user can access clock buttons based on server tier and roles.\"\"\"\n    guild_id = user.guild.id\n    \n    # All tiers: check clock roles OR admin access\n    # If no clock roles are configured, default to admin-only\n    employee_roles = get_employee_roles(guild_id)\n    if not employee_roles:\n        return user_has_admin_access(user)\n    \n    # Check if user has any of the configured clock roles\n    user_role_ids = [role.id for role in user.roles]\n    has_clock_role = any(role_id in user_role_ids for role_id in employee_roles)\n    \n    # Allow access if user has clock role OR admin access\n    return has_clock_role or user_has_admin_access(user)\n\n\ndef get_user_hours_info(guild_id: int, user_id: int, guild_tz_name: str = \"America/New_York\"):\n    \"\"\"Get current session, daily, and weekly hours for a user.\"\"\"\n    from zoneinfo import ZoneInfo\n    \n    try:\n        guild_tz = ZoneInfo(guild_tz_name)\n    except Exception:\n        guild_tz = timezone.utc\n    \n    now = datetime.now(timezone.utc)\n    \n    # Current session time\n    active_session = get_active_session(guild_id, user_id)\n    current_session_seconds = 0\n    if active_session:\n        session_id, clock_in_iso = active_session\n        start_dt = datetime.fromisoformat(clock_in_iso)\n        current_session_seconds = int((now - start_dt).total_seconds())\n    \n    # Get start of today and start of week in guild timezone\n    now_local = now.astimezone(guild_tz)\n    today_start = datetime.combine(now_local.date(), datetime.min.time()).replace(tzinfo=guild_tz)\n    \n    # Calculate start of week (Monday)\n    days_since_monday = now_local.weekday()\n    from datetime import timedelta\n    week_start = today_start - timedelta(days=days_since_monday)\n    \n    # Convert to UTC for database queries\n    today_start_utc = today_start.astimezone(timezone.utc).isoformat()\n    week_start_utc = week_start.astimezone(timezone.utc).isoformat()\n    now_utc = now.isoformat()\n    \n    with db() as conn:\n        # Daily hours (sessions that overlap with today)\n        daily_cur = conn.execute(\"\"\"\n            SELECT clock_in, clock_out FROM sessions\n            WHERE guild_id=? AND user_id=? AND clock_out IS NOT NULL\n            AND clock_in < ? AND clock_out >= ?\n        \"\"\", (guild_id, user_id, now_utc, today_start_utc))\n        daily_sessions = daily_cur.fetchall()\n        \n        daily_seconds = 0\n        for clock_in_iso, clock_out_iso in daily_sessions:\n            clock_in_dt = datetime.fromisoformat(clock_in_iso)\n            clock_out_dt = datetime.fromisoformat(clock_out_iso)\n            today_start_dt = datetime.fromisoformat(today_start_utc)\n            \n            # Calculate overlap with today\n            overlap_start = max(clock_in_dt, today_start_dt)\n            overlap_end = min(clock_out_dt, now)\n            \n            if overlap_end > overlap_start:\n                daily_seconds += int((overlap_end - overlap_start).total_seconds())\n        \n        # Weekly hours (sessions that overlap with this week)\n        weekly_cur = conn.execute(\"\"\"\n            SELECT clock_in, clock_out FROM sessions\n            WHERE guild_id=? AND user_id=? AND clock_out IS NOT NULL\n            AND clock_in < ? AND clock_out >= ?\n        \"\"\", (guild_id, user_id, now_utc, week_start_utc))\n        weekly_sessions = weekly_cur.fetchall()\n        \n        weekly_seconds = 0\n        for clock_in_iso, clock_out_iso in weekly_sessions:\n            clock_in_dt = datetime.fromisoformat(clock_in_iso)\n            clock_out_dt = datetime.fromisoformat(clock_out_iso)\n            week_start_dt = datetime.fromisoformat(week_start_utc)\n            \n            # Calculate overlap with this week\n            overlap_start = max(clock_in_dt, week_start_dt)\n            overlap_end = min(clock_out_dt, now)\n            \n            if overlap_end > overlap_start:\n                weekly_seconds += int((overlap_end - overlap_start).total_seconds())\n    \n    return current_session_seconds, daily_seconds, weekly_seconds\n\nasync def generate_csv_report(bot, sessions_data, guild_id, guild_tz=\"America/New_York\"):\n    \"\"\"Generate organized CSV content from sessions data with usernames.\"\"\"\n    output = io.StringIO()\n    writer = csv.writer(output)\n    \n    # Group sessions by user\n    user_sessions = {}\n    for user_id, clock_in_iso, clock_out_iso, duration_seconds in sessions_data:\n        if user_id not in user_sessions:\n            user_sessions[user_id] = []\n        user_sessions[user_id].append((clock_in_iso, clock_out_iso, duration_seconds))\n    \n    # Generate organized format for each user\n    for user_id, sessions in user_sessions.items():\n        # Fetch Discord user to get display name based on guild preference\n        try:\n            discord_user = await bot.fetch_user(user_id)\n            user_display_name = get_user_display_name(discord_user, guild_id)\n        except:\n            user_display_name = f\"User-{user_id}\"  # Fallback if user not found\n        \n        # Calculate date range for this user\n        all_dates = []\n        for clock_in_iso, _, _ in sessions:\n            clock_in_dt = datetime.fromisoformat(clock_in_iso)\n            date_formatted = fmt(clock_in_dt, guild_tz).split()[0]\n            all_dates.append(date_formatted)\n        \n        date_range = f\"{min(all_dates)} to {max(all_dates)}\" if len(set(all_dates)) > 1 else min(all_dates)\n        \n        # Employee header with username\n        writer.writerow([f\"Employee: {user_display_name} - Shift Report ({date_range})\"])\n        writer.writerow([])  # Empty row\n        \n        # Process each session for this user\n        for clock_in_iso, clock_out_iso, duration_seconds in sessions:\n            # Parse timestamps\n            clock_in_dt = datetime.fromisoformat(clock_in_iso)\n            clock_out_dt = datetime.fromisoformat(clock_out_iso)\n            \n            # Format day and times\n            day_of_week = clock_in_dt.strftime(\"%A\")  # Full day name\n            date_str = fmt(clock_in_dt, guild_tz).split()[0]\n            in_time = fmt(clock_in_dt, guild_tz).split()[1:3]  # Time and timezone\n            out_time = fmt(clock_out_dt, guild_tz).split()[1:3]\n            \n            # Duration in decimal hours\n            total_hours = round(duration_seconds / 3600, 2)\n            \n            # Write shift details\n            writer.writerow([f\"{day_of_week} ({date_str}):\"])\n            writer.writerow([f\"IN - {' '.join(in_time)}\"])\n            writer.writerow([f\"OUT - {' '.join(out_time)}\"])\n            writer.writerow([f\"{total_hours} total hours\"])\n            writer.writerow([])  # Empty row between shifts\n        \n        # Add separator between employees\n        writer.writerow([\"=\" * 50])\n        writer.writerow([])\n    \n    return output.getvalue()\n\nasync def generate_individual_csv_report(bot, user_id, sessions, guild_id, guild_tz=\"America/New_York\"):\n    \"\"\"Generate CSV for a single user.\"\"\"\n    output = io.StringIO()\n    writer = csv.writer(output)\n    \n    # Fetch Discord user to get display name based on guild preference\n    try:\n        discord_user = await bot.fetch_user(user_id)\n        user_display_name = get_user_display_name(discord_user, guild_id)\n    except:\n        user_display_name = f\"User-{user_id}\"  # Fallback if user not found\n    \n    # Calculate date range for this user\n    all_dates = []\n    for clock_in_iso, _, _ in sessions:\n        clock_in_dt = datetime.fromisoformat(clock_in_iso)\n        date_formatted = fmt(clock_in_dt, guild_tz).split()[0]\n        all_dates.append(date_formatted)\n    \n    date_range = f\"{min(all_dates)} to {max(all_dates)}\" if len(set(all_dates)) > 1 else min(all_dates)\n    \n    # Employee header with username\n    writer.writerow([f\"Employee: {user_display_name} - Shift Report ({date_range})\"])\n    writer.writerow([])  # Empty row\n    \n    # Process each session for this user\n    for clock_in_iso, clock_out_iso, duration_seconds in sessions:\n        # Parse timestamps\n        clock_in_dt = datetime.fromisoformat(clock_in_iso)\n        clock_out_dt = datetime.fromisoformat(clock_out_iso)\n        \n        # Format day and times\n        day_of_week = clock_in_dt.strftime(\"%A\")  # Full day name\n        date_str = fmt(clock_in_dt, guild_tz).split()[0]\n        in_time = fmt(clock_in_dt, guild_tz).split()[1:3]  # Time and timezone\n        out_time = fmt(clock_out_dt, guild_tz).split()[1:3]\n        \n        # Duration in decimal hours\n        total_hours = round(duration_seconds / 3600, 2)\n        \n        # Write shift details\n        writer.writerow([f\"{day_of_week} ({date_str}):\"])\n        writer.writerow([f\"IN - {' '.join(in_time)}\"])\n        writer.writerow([f\"OUT - {' '.join(out_time)}\"])\n        writer.writerow([f\"{total_hours} total hours\"])\n        writer.writerow([])  # Empty row between shifts\n    \n    return output.getvalue(), user_display_name\n\n# --- Time helpers ---\ndef now_utc():\n    return datetime.now(timezone.utc)\n\ndef fmt(dt: datetime, tz_name: Optional[str]) -> str:\n    try:\n        from zoneinfo import ZoneInfo\n        tz = ZoneInfo(tz_name) if tz_name else ZoneInfo(\"America/New_York\")\n    except Exception:\n        tz = timezone.utc\n    return dt.astimezone(tz).strftime(\"%Y-%m-%d %H:%M:%S %Z\")\n\ndef human_duration(seconds: int) -> str:\n    h = seconds // 3600\n    m = (seconds % 3600) // 60\n    s = seconds % 60\n    parts = []\n    if h: parts.append(f\"{h}h\")\n    if m: parts.append(f\"{m}m\")\n    if s or not parts: parts.append(f\"{s}s\")\n    return \" \".join(parts)\n\ndef format_duration_hhmmss(seconds: int) -> str:\n    \"\"\"Format seconds into HH:MM:SS format\"\"\"\n    h = int(seconds // 3600)\n    m = int((seconds % 3600) // 60)\n    s = int(seconds % 60)\n    return f\"{h:02d}:{m:02d}:{s:02d}\"\n\ndef purge_timeclock_data_only(guild_id: int):\n    \"\"\"Standalone function to purge only timeclock sessions data, preserving subscription and core settings\"\"\"\n    try:\n        with db() as conn:\n            # Set timeout for database operations\n            conn.execute(\"PRAGMA busy_timeout = 5000\")\n            \n            # Delete all sessions data only\n            sessions_cursor = conn.execute(\"DELETE FROM sessions WHERE guild_id = ?\", (guild_id,))\n            sessions_deleted = sessions_cursor.rowcount\n            \n            print(f\"üóëÔ∏è Timeclock data purged for Guild {guild_id}: {sessions_deleted} sessions deleted (subscription preserved)\")\n            \n    except Exception as e:\n        print(f\"‚ùå Error purging timeclock data for {guild_id}: {e}\")\n        raise e  # Re-raise so the error can be caught by the calling function\n\ndef format_shift_duration(seconds: int) -> str:\n    \"\"\"Format seconds into clean 'X hrs Y mins' format\"\"\"\n    h = int(seconds // 3600)\n    m = int((seconds % 3600) // 60)\n    s = int(seconds % 60)\n    \n    if h > 0:\n        return f\"{h} hr{'s' if h != 1 else ''} {m} min{'s' if m != 1 else ''}\"\n    elif m > 0:\n        return f\"{m} min{'s' if m != 1 else ''} {s} sec{'s' if s != 1 else ''}\"\n    else:\n        return f\"{s} second{'s' if s != 1 else ''}\"\n\ndef sanitize_filename(filename: str) -> str:\n    \"\"\"Sanitize filename to prevent path traversal and ensure safe file names\"\"\"\n    import re\n    \n    # Remove path separators and other unsafe characters\n    filename = re.sub(r'[/\\\\:*?\"<>|]', '_', filename)\n    \n    # Replace multiple underscores with single underscore\n    filename = re.sub(r'_+', '_', filename)\n    \n    # Remove leading/trailing whitespace and underscores\n    filename = filename.strip(' _')\n    \n    # Limit length to 50 characters\n    if len(filename) > 50:\n        filename = filename[:47] + '...'\n    \n    # Ensure we don't end up with empty filename\n    if not filename or filename.isspace():\n        filename = \"user\"\n    \n    return filename\n\n# --- Discord bot ---\nintents = discord.Intents.default()\n# Note: members intent requires privileged intent in Discord Developer Portal\n# For now, we'll use a fallback approach that works with default intents\nbot = commands.Bot(command_prefix=\"!\", intents=intents)\ntree = bot.tree\n\n# Register persistent views at startup to handle interactions after bot restart\nasync def setup_hook():\n    \"\"\"Setup hook to register persistent views when bot starts\"\"\"\n    print(\"üîß Registering persistent views...\")\n    \n    # Register ONLY empty TimeClockView for handling interactions\n    # This prevents old buttons from appearing in channels\n    bot.add_view(TimeClockView())\n    print(\"‚úÖ TimeClockView registered\")\n    \n    print(\"‚úÖ Persistent view setup complete - ephemeral interface mode\")\n\nbot.setup_hook = setup_hook\n\nclass TimeClockView(discord.ui.View):\n    def __init__(self, guild_id: Optional[int] = None):\n        super().__init__(timeout=None)  # persistent view\n        self.guild_id = guild_id\n        \n        # If guild_id is provided, build conditional view\n        if guild_id:\n            self._build_conditional_view(guild_id)\n\n    def _build_conditional_view(self, guild_id: int):\n        \"\"\"Build view with conditional buttons based on server tier\"\"\"\n        server_tier = get_server_tier(guild_id)\n        \n        # Add core buttons (row 0) - Clock In first, On the Clock last\n        clock_in_btn = discord.ui.Button(\n            label=\"Clock In\", \n            style=discord.ButtonStyle.success, \n            custom_id=\"timeclock:clock_in\", \n            row=0\n        )\n        clock_in_btn.callback = self.clock_in\n        self.add_item(clock_in_btn)\n        \n        clock_out_btn = discord.ui.Button(\n            label=\"Clock Out\", \n            style=discord.ButtonStyle.danger, \n            custom_id=\"timeclock:clock_out\", \n            row=0\n        )\n        clock_out_btn.callback = self.clock_out\n        self.add_item(clock_out_btn)\n        \n        help_btn = discord.ui.Button(\n            label=\"Help\", \n            style=discord.ButtonStyle.primary, \n            custom_id=\"timeclock:help\", \n            row=0\n        )\n        help_btn.callback = self.show_help\n        self.add_item(help_btn)\n        \n        on_clock_btn = discord.ui.Button(\n            label=\"On the Clock\", \n            style=discord.ButtonStyle.secondary, \n            custom_id=\"timeclock:onclock\", \n            row=0\n        )\n        on_clock_btn.callback = self.on_the_clock\n        self.add_item(on_clock_btn)\n        \n        # Conditional second row buttons\n        if server_tier == \"free\":\n            # Add upgrade button for free servers\n            upgrade_btn = discord.ui.Button(\n                label=\"Upgrade\", \n                style=discord.ButtonStyle.secondary, \n                custom_id=\"timeclock:upgrade\", \n                emoji=\"üöÄ\",\n                row=1\n            )\n            upgrade_btn.callback = self.show_upgrade\n            self.add_item(upgrade_btn)\n        else:\n            # Add reports button for paid servers\n            reports_btn = discord.ui.Button(\n                label=\"Reports\", \n                style=discord.ButtonStyle.success, \n                custom_id=\"timeclock:reports\", \n                row=1\n            )\n            reports_btn.callback = self.generate_reports\n            self.add_item(reports_btn)\n\n    async def on_the_clock(self, interaction: discord.Interaction):\n        \"\"\"Show all currently clocked in users with their times\"\"\"\n        # Robust defer with proper fallback\n        defer_success = await robust_defer(interaction, ephemeral=True)\n        if not defer_success and not interaction.response.is_done():\n            # If defer failed and interaction isn't done, we can't proceed\n            return\n        \n        if interaction.guild is None:\n            await interaction.followup.send(\"Use this in a server.\", ephemeral=True)\n            return\n            \n        guild_id = interaction.guild.id\n        \n        # Check clock access permissions\n        server_tier = get_server_tier(guild_id)\n        # Type guard: ensure we have a Member for guild-specific functions\n        if not isinstance(interaction.user, discord.Member):\n            await interaction.followup.send(\n                \"‚ùå Unable to verify access permissions. Please try again.\",\n                ephemeral=True\n            )\n            return\n        \n        if not user_has_clock_access(interaction.user, server_tier):\n            await interaction.followup.send(\n                \"üîí **Access Restricted**\\n\"\n                \"You need an employee role to use the timeclock.\\n\"\n                \"Ask an administrator to add your role with `/add_employee_role @yourrole`\",\n                ephemeral=True\n            )\n            return\n        \n        try:\n            # Get all currently clocked in users\n            with db() as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT user_id, clock_in \n                    FROM sessions \n                    WHERE guild_id = ? AND clock_out IS NULL\n                    ORDER BY clock_in ASC\n                \"\"\", (guild_id,))\n                active_sessions = cursor.fetchall()\n            \n            if not active_sessions:\n                embed = discord.Embed(\n                    title=\"‚è∞ On the Clock\",\n                    description=\"No one is currently clocked in.\",\n                    color=discord.Color.gold()\n                )\n                await interaction.followup.send(embed=embed, ephemeral=True)\n                return\n            \n            # Get timezone setting\n            tz_name = get_guild_setting(guild_id, \"timezone\", DEFAULT_TZ)\n            \n            try:\n                from zoneinfo import ZoneInfo\n                guild_tz = ZoneInfo(tz_name or DEFAULT_TZ)\n            except (ImportError, Exception):\n                # If timezone or ZoneInfo import fails, fallback to EST instead of UTC\n                try:\n                    from zoneinfo import ZoneInfo\n                    guild_tz = ZoneInfo(DEFAULT_TZ)\n                    tz_name = \"America/New_York (EST)\"\n                except ImportError:\n                    # ZoneInfo not available, use UTC\n                    guild_tz = timezone.utc\n                    tz_name = \"UTC\"\n            \n            embed = discord.Embed(\n                title=\"üïí Team Currently On the Clock\",\n                description=f\"üìä **{len(active_sessions)} active team member{'s' if len(active_sessions) != 1 else ''}**\",\n                color=discord.Color.blurple()\n            )\n            \n            now_utc = datetime.now(timezone.utc)\n            \n            # Sort users by clock in time for organized display\n            sorted_sessions = sorted(active_sessions, key=lambda x: x[1])\n            \n            user_details = []\n            for i, (user_id, clock_in_iso) in enumerate(sorted_sessions, 1):\n                try:\n                    # Get user with proper Discord nickname\n                    user = interaction.guild.get_member(user_id)\n                    if user:\n                        # Always use Discord nickname (display_name) which includes server nick\n                        display_name = user.display_name\n                        user_mention = user.mention\n                    else:\n                        # Fallback to trying to get user from cache\n                        try:\n                            user = await interaction.client.fetch_user(user_id)\n                            display_name = user.display_name if hasattr(user, 'display_name') else user.name\n                            user_mention = f\"<@{user_id}>\"\n                        except:\n                            display_name = f\"Unknown User\"\n                            user_mention = f\"<@{user_id}>\"\n                    \n                    # Parse clock in time\n                    clock_in_utc = datetime.fromisoformat(clock_in_iso.replace('Z', '+00:00'))\n                    clock_in_local = clock_in_utc.astimezone(guild_tz)\n                    \n                    # Calculate total time for today in this timezone\n                    local_date = clock_in_local.date()\n                    day_start = datetime.combine(local_date, datetime.min.time()).replace(tzinfo=guild_tz)\n                    day_end = datetime.combine(local_date, datetime.max.time()).replace(tzinfo=guild_tz)\n                    \n                    # Get all sessions for today\n                    day_start_utc = day_start.astimezone(timezone.utc).isoformat()\n                    day_end_utc = day_end.astimezone(timezone.utc).isoformat()\n                    \n                    with db() as conn:\n                        cursor = conn.execute(\"\"\"\n                            SELECT clock_in, clock_out \n                            FROM sessions \n                            WHERE guild_id = ? AND user_id = ? \n                            AND clock_in >= ? AND clock_in <= ?\n                        \"\"\", (guild_id, user_id, day_start_utc, day_end_utc))\n                        day_sessions = cursor.fetchall()\n                    \n                    # Calculate total day seconds\n                    total_day_seconds = 0\n                    for session_in, session_out in day_sessions:\n                        if session_out:  # Completed session\n                            start = datetime.fromisoformat(session_in.replace('Z', '+00:00'))\n                            end = datetime.fromisoformat(session_out.replace('Z', '+00:00'))\n                            total_day_seconds += (end - start).total_seconds()\n                        else:  # Current active session\n                            start = datetime.fromisoformat(session_in.replace('Z', '+00:00'))\n                            total_day_seconds += (now_utc - start).total_seconds()\n                    \n                    # Current shift time\n                    shift_seconds = (now_utc - clock_in_utc).total_seconds()\n                    \n                    # Format times\n                    clock_in_time = clock_in_local.strftime(\"%I:%M %p\")\n                    total_day_time = format_duration_hhmmss(int(total_day_seconds))\n                    shift_time = format_shift_duration(int(shift_seconds))\n                    \n                    # Create fancy formatted entry\n                    user_entry = (\n                        f\"**#{i}** {user_mention} ‚Ä¢ **{display_name}**\\n\"\n                        f\"üü¢ **Clocked In:** {clock_in_time}\\n\"\n                        f\"üìÖ **Today's Total:** {total_day_time}\\n\"\n                        f\"‚è±Ô∏è **Current Shift:** {shift_time}\\n\"\n                        f\"{'‚îÄ' * 35}\"\n                    )\n                    user_details.append(user_entry)\n                    \n                except Exception as e:\n                    print(f\"Error processing user {user_id}: {e}\")\n                    # Fallback with better formatting even for errors\n                    user_entry = (\n                        f\"**#{i}** <@{user_id}> ‚Ä¢ **Unknown User**\\n\"\n                        f\"‚ùå **Error loading time data**\\n\"\n                        f\"{'‚îÄ' * 35}\"\n                    )\n                    user_details.append(user_entry)\n            \n            # Add users to embed with nice organization\n            if len(user_details) <= 3:\n                # If 3 or fewer users, show them all in one field\n                embed.add_field(\n                    name=\"üë• Active Team Members\",\n                    value=\"\\n\".join(user_details),\n                    inline=False\n                )\n            else:\n                # If more than 3 users, split into multiple fields for better organization\n                mid_point = len(user_details) // 2\n                \n                embed.add_field(\n                    name=\"üë• Active Team Members (Part 1)\",\n                    value=\"\\n\".join(user_details[:mid_point]),\n                    inline=True\n                )\n                \n                embed.add_field(\n                    name=\"üë• Active Team Members (Part 2)\", \n                    value=\"\\n\".join(user_details[mid_point:]),\n                    inline=True\n                )\n            \n            embed.add_field(\n                name=\"Timezone\",\n                value=tz_name,\n                inline=True\n            )\n            \n            await interaction.followup.send(embed=embed, ephemeral=True)\n            \n        except Exception as e:\n            await interaction.followup.send(\n                \"‚ùå Error retrieving active users. Please try again.\", \n                ephemeral=True\n            )\n            print(f\"Error in on_the_clock: {e}\")\n\n    async def clock_in(self, interaction: discord.Interaction):\n        \"\"\"Handle clock in button interaction with robust error handling\"\"\"\n        # Robust defer with proper fallback\n        defer_success = await robust_defer(interaction, ephemeral=True)\n        if not defer_success and not interaction.response.is_done():\n            # If defer failed and interaction isn't done, we can't proceed\n            return\n        \n        try:\n            if interaction.guild is None:\n                await interaction.followup.send(\"Use this in a server.\", ephemeral=True)\n                return\n                \n            guild_id = interaction.guild.id\n            user_id = interaction.user.id\n            \n            # Check clock access permissions\n            server_tier = get_server_tier(guild_id)\n            # Type guard: ensure we have a Member for guild-specific functions\n            if not isinstance(interaction.user, discord.Member):\n                await interaction.followup.send(\n                    \"‚ùå Unable to verify access permissions. Please try again.\",\n                    ephemeral=True\n                )\n                return\n            \n            if not user_has_clock_access(interaction.user, server_tier):\n                await interaction.followup.send(\n                    \"üîí **Access Restricted**\\n\"\n                    \"You need an employee role to use the timeclock.\\n\"\n                    \"Ask an administrator to add your role with `/add_employee_role @yourrole`\",\n                    ephemeral=True\n                )\n                return\n            \n            if get_active_session(guild_id, user_id):\n                await interaction.followup.send(\"You're already clocked in.\", ephemeral=True)\n                return\n                \n            start_session(guild_id, user_id, now_utc().isoformat())\n            await interaction.followup.send(\"‚úÖ Clocked in. Have a great shift!\", ephemeral=True)\n            \n        except (discord.NotFound, discord.errors.NotFound):\n            # Interaction expired or was deleted - silently handle this\n            print(f\"‚ö†Ô∏è Clock in interaction expired/not found for user {interaction.user.id}\")\n        except discord.errors.InteractionResponded:\n            # Interaction was already responded to - try followup\n            try:\n                await interaction.followup.send(\"‚ùå Button interaction error. Please try again.\", ephemeral=True)\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Failed to send followup after InteractionResponded: {e}\")\n        except Exception as e:\n            # General error handling\n            print(f\"‚ùå Error in clock_in callback: {e}\")\n            try:\n                if not interaction.response.is_done():\n                    await interaction.response.send_message(\"‚ùå An error occurred. Please try again.\", ephemeral=True)\n                else:\n                    await interaction.followup.send(\"‚ùå An error occurred. Please try again.\", ephemeral=True)\n            except Exception:\n                # If we can't even send an error message, just log it\n                print(f\"‚ùå Failed to send error message for clock_in: {e}\")\n\n    async def clock_out(self, interaction: discord.Interaction):\n        \"\"\"Handle clock out button interaction with robust error handling\"\"\"\n        # Robust defer with proper fallback\n        defer_success = await robust_defer(interaction, ephemeral=True)\n        if not defer_success and not interaction.response.is_done():\n            # If defer failed and interaction isn't done, we can't proceed\n            return\n        \n        try:\n            if interaction.guild is None:\n                await interaction.followup.send(\"Use this in a server.\", ephemeral=True)\n                return\n                \n            guild_id = interaction.guild.id\n            user_id = interaction.user.id\n            \n            # Check clock access permissions\n            server_tier = get_server_tier(guild_id)\n            # Type guard: ensure we have a Member for guild-specific functions\n            if not isinstance(interaction.user, discord.Member):\n                await interaction.followup.send(\n                    \"‚ùå Unable to verify access permissions. Please try again.\",\n                    ephemeral=True\n                )\n                return\n            \n            if not user_has_clock_access(interaction.user, server_tier):\n                await interaction.followup.send(\n                    \"üîí **Access Restricted**\\n\"\n                    \"You need an employee role to use the timeclock.\\n\"\n                    \"Ask an administrator to add your role with `/add_employee_role @yourrole`\",\n                    ephemeral=True\n                )\n                return\n            \n            active = get_active_session(guild_id, user_id)\n            if not active:\n                await interaction.followup.send(\"You don't have an active session.\", ephemeral=True)\n                return\n\n            session_id, clock_in_iso = active\n            start_dt = datetime.fromisoformat(clock_in_iso)\n            end_dt = now_utc()\n            elapsed = int((end_dt - start_dt).total_seconds())\n            close_session(session_id, end_dt.isoformat(), elapsed)\n\n            tz_name = get_guild_setting(guild_id, \"timezone\", DEFAULT_TZ) or DEFAULT_TZ\n            await interaction.followup.send(\n                f\"üîö Clocked out.\\n**In:** {fmt(start_dt, tz_name)}\\n**Out:** {fmt(end_dt, tz_name)}\\n**Total:** {human_duration(elapsed)}\",\n                ephemeral=True\n            )\n\n            # Send notifications to all configured recipients\n            await send_timeclock_notifications(guild_id, interaction, start_dt, end_dt, elapsed, tz_name)\n                        \n        except (discord.NotFound, discord.errors.NotFound):\n            # Interaction expired or was deleted - silently handle this\n            print(f\"‚ö†Ô∏è Clock out interaction expired/not found for user {interaction.user.id}\")\n        except discord.errors.InteractionResponded:\n            # Interaction was already responded to - try followup\n            try:\n                await interaction.followup.send(\"‚ùå Button interaction error. Please try again.\", ephemeral=True)\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Failed to send followup after InteractionResponded: {e}\")\n        except Exception as e:\n            # General error handling\n            print(f\"‚ùå Error in clock_out callback: {e}\")\n            try:\n                if not interaction.response.is_done():\n                    await interaction.response.send_message(\"‚ùå An error occurred. Please try again.\", ephemeral=True)\n                else:\n                    await interaction.followup.send(\"‚ùå An error occurred. Please try again.\", ephemeral=True)\n            except Exception:\n                # If we can't even send an error message, just log it\n                print(f\"‚ùå Failed to send error message for clock_out: {e}\")\n\n    async def show_help(self, interaction: discord.Interaction):\n        \"\"\"Show help commands instead of user time info with robust error handling\"\"\"\n        try:\n            if interaction.guild is None:\n                await send_reply(interaction, \"Use this in a server.\", ephemeral=True)\n                return\n            \n            # Check clock access permissions\n            server_tier = get_server_tier(interaction.guild.id)\n            # Type guard: ensure we have a Member for guild-specific functions\n            if not isinstance(interaction.user, discord.Member):\n                await send_reply(interaction,\n                    \"‚ùå Unable to verify access permissions. Please try again.\",\n                    ephemeral=True\n                )\n                return\n            \n            if not user_has_clock_access(interaction.user, server_tier):\n                await send_reply(interaction,\n                    \"üîí **Access Restricted**\\n\"\n                    \"You need an employee role to use the timeclock.\\n\"\n                    \"Ask an administrator to add your role with `/add_employee_role @yourrole`\",\n                    ephemeral=True\n                )\n                return\n            \n            # Get current server tier for comprehensive help display\n            server_tier = get_server_tier(interaction.guild.id)\n            tier_color = {\"free\": discord.Color.green(), \"basic\": discord.Color.blue(), \"pro\": discord.Color.purple()}\n            \n            embed = discord.Embed(\n                title=\"üìã Complete Command Reference\",\n                description=f\"**Current Plan:** {server_tier.title()}\\n\\n**All 21 available slash commands organized by function:**\",\n                color=tier_color.get(server_tier, discord.Color.green())\n            )\n        \n            # Setup & Configuration Commands\n            embed.add_field(\n                name=\"‚öôÔ∏è Setup & Configuration\",\n                value=(\n                    \"`/setup_timeclock [channel]` - Post a persistent Clock In/Clock Out message\\n\"\n                    \"`/set_recipient <user>` - Set who receives private time entries (DMs)\\n\"\n                    \"`/set_timezone <timezone>` - Set display timezone (e.g., America/New_York)\\n\"\n                    \"`/toggle_name_display` - Toggle between username and nickname display\\n\"\n                    \"`/help` - List all available slash commands\"\n                ),\n                inline=False\n            )\n            \n            # Admin Role Management Commands\n            embed.add_field(\n                name=\"üë§ Admin Role Management\",\n                value=(\n                    \"`/add_admin_role <role>` - Add a role that can access Reports and Upgrade buttons\\n\"\n                    \"`/remove_admin_role <role>` - Remove a role's admin access to Reports and Upgrade buttons\\n\"\n                    \"`/list_admin_roles` - List all roles with admin access\\n\"\n                    \"`/set_main_role <role>` - Set the primary admin role (gets all admin functions)\\n\"\n                    \"`/show_main_role` - View the current main admin role\\n\"\n                    \"`/clear_main_role` - Remove the main admin role designation\"\n                ),\n                inline=False\n            )\n            \n            # Employee Role Management Commands\n            embed.add_field(\n                name=\"üë• Employee Role Management\",\n                value=(\n                    \"`/add_employee_role <role>` - Add a role that can use timeclock functions\\n\"\n                    \"`/remove_employee_role <role>` - Remove a role's access to timeclock functions\\n\"\n                    \"`/list_employee_roles` - List all roles that can use timeclock functions\"\n                ),\n                inline=False\n            )\n            \n            # Reports & Data Management Commands\n            embed.add_field(\n                name=\"üìä Reports & Data Management\",\n                value=(\n                    \"`/report <user> <start_date> <end_date>` - Generate CSV timesheet report for individual user\\n\"\n                    \"`/data_cleanup` - Manually trigger data cleanup (Admin only)\\n\"\n                    \"`/purge` - Permanently delete timeclock data (preserves subscription)\"\n                ),\n                inline=False\n            )\n            \n            # Subscription Management Commands\n            embed.add_field(\n                name=\"üí≥ Subscription Management\",\n                value=(\n                    \"`/upgrade` - Upgrade your server to Basic or Pro plan\\n\"\n                    \"`/cancel_subscription` - Learn how to cancel your subscription\\n\"\n                    \"`/subscription_status` - View current subscription status\"\n                ),\n                inline=False\n            )\n            \n            # Tier Information & Features\n            tier_info = \"\\n\\n**Plan Features:**\\n\"\n            if server_tier == \"free\":\n                tier_info += (\n                    \"üÜì **Free Tier:** Admin-only testing ‚Ä¢ Sample reports ‚Ä¢ Employee roles configured but inactive\\n\"\n                    \"üí° **Upgrade Benefits:** Basic ($5/mo) unlocks full team access & real CSV reports\"\n                )\n            elif server_tier == \"basic\":\n                tier_info += (\n                    \"üíô **Basic Tier:** Full team access ‚Ä¢ Real CSV reports ‚Ä¢ 7-day data retention\\n\"\n                    \"üí° **Pro Benefits:** 30-day retention ‚Ä¢ Multiple manager notifications ‚Ä¢ Extended features\"\n                )\n            else:  # pro tier\n                tier_info += \"üíú **Pro Tier:** All features unlocked ‚Ä¢ 30-day retention ‚Ä¢ Multiple managers ‚Ä¢ Priority support\"\n            \n            embed.add_field(\n                name=\"üîò Interactive Timeclock Buttons\",\n                value=(\n                    \"üü¢ **Clock In** - Start tracking your time\\n\"\n                    \"üî¥ **Clock Out** - Stop tracking and log your shift\\n\"\n                    \"üìä **Reports** - Generate timesheet reports (admin access)\\n\"\n                    \"‚¨ÜÔ∏è **Upgrade** - Upgrade to Basic/Pro plans\\n\" + \n                    tier_info\n                ),\n                inline=False\n            )\n        \n            embed.set_footer(text=f\"üí° {server_tier.title()} Plan Active | 20 total commands available | Contact admin for upgrades\")\n            \n            await send_reply(interaction, embed=embed, ephemeral=True)\n            \n        except (discord.NotFound, discord.errors.NotFound):\n            # Interaction expired or was deleted - silently handle this\n            print(f\"‚ö†Ô∏è Help interaction expired/not found for user {interaction.user.id}\")\n        except Exception as e:\n            # General error handling\n            print(f\"‚ùå Error in show_help callback: {e}\")\n            try:\n                await send_reply(interaction, \"‚ùå An error occurred while showing help. Please try again.\", ephemeral=True)\n            except Exception:\n                # If we can't even send an error message, just log it\n                print(f\"‚ùå Failed to send error message for show_help: {e}\")\n\n    async def generate_reports(self, interaction: discord.Interaction):\n        # Robust defer with proper fallback\n        defer_success = await robust_defer(interaction, ephemeral=True)\n        if not defer_success and not interaction.response.is_done():\n            # If defer failed and interaction isn't done, we can't proceed\n            return\n            \n        try:\n            \n            if interaction.guild is None:\n                await interaction.followup.send(\"Use this in a server.\", ephemeral=True)\n                return\n            \n            # Check if user has admin access (Discord admin OR custom admin role)\n            # Type guard: ensure we have a Member for guild-specific functions\n            if not isinstance(interaction.user, discord.Member):\n                await interaction.followup.send(\n                    \"‚ùå Unable to verify admin permissions. Please try again.\",\n                    ephemeral=True\n                )\n                return\n            \n            if not user_has_admin_access(interaction.user):\n                await interaction.followup.send(\n                    \"‚ùå **Access Denied - Admin Role Required**\\n\\n\"\n                    \"You need administrator permissions or an admin role to generate reports.\\n\\n\"\n                    \"**To get access:**\\n\"\n                    \"‚Ä¢ Ask your server administrator to grant you admin role access\\n\"\n                    \"‚Ä¢ They can use: `/add_admin_role @yourrole` to give your role admin access\\n\"\n                    \"‚Ä¢ Or ask them to add you to an existing admin role\\n\\n\"\n                    \"üí° Contact your server admin for help with role management.\", \n                    ephemeral=True\n                )\n                return\n            \n            guild_id = interaction.guild.id\n            server_tier = get_server_tier(guild_id)\n            \n            # Free tier: Admin only + fake data \n            if server_tier == \"free\":\n                fake_csv = \"Date,Clock In,Clock Out,Duration\\n2024-01-01,09:00,17:00,8.0 hours\\nThis is the free version, please upgrade for more options\"\n                filename = f\"sample_report_last_30_days.csv\"\n                \n                file = discord.File(\n                    io.BytesIO(fake_csv.encode('utf-8')), \n                    filename=filename\n                )\n            \n                await interaction.followup.send(\n                    f\"üìä **Free Tier Sample Report**\\n\"\n                    f\"üéØ This is sample data. Upgrade to Basic ($5/month) or Pro ($10/month) for real reports!\\n\"\n                    f\"üìÖ Date Range: Last 30 days\",\n                    file=file,\n                    ephemeral=True\n                )\n                return\n            \n            # Basic and Pro tier: Full reports access with retention limits\n            guild_tz_name = get_guild_setting(guild_id, \"timezone\", DEFAULT_TZ)\n            if guild_tz_name is None:\n                guild_tz_name = DEFAULT_TZ\n            \n            # Determine report range based on tier\n            if server_tier == \"basic\":\n                report_days = 7  # Basic tier: 7 days max\n            else:  # pro tier\n                report_days = 30  # Pro tier: 30 days max\n            \n            # Generate report for tier-appropriate days\n            from zoneinfo import ZoneInfo\n            from datetime import timedelta\n            try:\n                guild_tz = ZoneInfo(guild_tz_name or DEFAULT_TZ)\n            except Exception:\n                guild_tz = timezone.utc\n                guild_tz_name = \"UTC\"\n            \n            # Calculate date range based on tier limits\n            end_date = datetime.now(guild_tz)\n            start_date = end_date - timedelta(days=report_days)\n            \n            start_boundary = datetime.combine(start_date.date(), datetime.min.time()).replace(tzinfo=guild_tz)\n            end_boundary = datetime.combine(end_date.date(), datetime.max.time()).replace(tzinfo=guild_tz)\n            \n            start_utc = start_boundary.astimezone(timezone.utc).isoformat()\n            end_utc = end_boundary.astimezone(timezone.utc).isoformat()\n            \n            # Get all user sessions\n            sessions_data = get_sessions_report(guild_id, None, start_utc, end_utc)\n            \n            if not sessions_data:\n                await interaction.followup.send(\n                    f\"üì≠ No completed timesheet entries found for the last {report_days} days\",\n                    ephemeral=True\n                )\n                return\n            \n            # Group sessions by user\n            user_sessions = {}\n            for user_id, clock_in_iso, clock_out_iso, duration_seconds in sessions_data:\n                if user_id not in user_sessions:\n                    user_sessions[user_id] = []\n                user_sessions[user_id].append((clock_in_iso, clock_out_iso, duration_seconds))\n            \n            # Generate CSV files for each user\n            total_users = len(user_sessions)\n            total_entries = len(sessions_data)\n            start_date_str = start_date.strftime(\"%Y-%m-%d\")\n            end_date_str = end_date.strftime(\"%Y-%m-%d\")\n            tier_note = f\"({server_tier.title()} tier - {report_days} days max)\" if server_tier == \"basic\" else f\"({server_tier.title()} tier)\"\n            \n            if total_users == 1:\n                # Single user: Send CSV file directly (not zipped)\n                user_id, sessions = next(iter(user_sessions.items()))\n                csv_content, user_display_name = await generate_individual_csv_report(bot, user_id, sessions, guild_id, guild_tz_name or DEFAULT_TZ)\n                \n                safe_user_name = sanitize_filename(user_display_name)\n                filename = f\"timesheet_report_{start_date_str}_to_{end_date_str}_{safe_user_name}.csv\"\n                file = discord.File(\n                    io.BytesIO(csv_content.encode('utf-8')), \n                    filename=filename\n                )\n                \n                await interaction.followup.send(\n                    f\"üìä Generated timesheet report for **{user_display_name}** {tier_note}\\n\"\n                    f\"üìÖ **Period:** Last {report_days} days ({start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')})\\n\"\n                    f\"üìù **Total Entries:** {total_entries} completed shifts\\n\"\n                    f\"üïê **Timezone:** {guild_tz_name}\",\n                    file=file,\n                    ephemeral=True\n                )\n            else:\n                # Multiple users: Create zip file containing all CSV files\n                zip_buffer = io.BytesIO()\n                \n                with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_archive:\n                    for user_id, sessions in user_sessions.items():\n                        csv_content, user_display_name = await generate_individual_csv_report(bot, user_id, sessions, guild_id, guild_tz_name or DEFAULT_TZ)\n                        safe_user_name = sanitize_filename(user_display_name)\n                        csv_filename = f\"timesheet_report_{start_date_str}_to_{end_date_str}_{safe_user_name}.csv\"\n                        # Explicitly encode CSV content to UTF-8 bytes for zip\n                        zip_archive.writestr(csv_filename, csv_content.encode('utf-8'))\n                \n                zip_buffer.seek(0)\n                zip_filename = f\"timesheet_reports_{start_date_str}_to_{end_date_str}_all_users.zip\"\n                \n                zip_discord_file = discord.File(zip_buffer, filename=zip_filename)\n                \n                await interaction.followup.send(\n                    f\"üìä Generated timesheet reports for **{total_users} users** {tier_note}\\n\"\n                    f\"üìÖ **Period:** Last {report_days} days ({start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')})\\n\"\n                    f\"üìù **Total Entries:** {total_entries} completed shifts\\n\"\n                    f\"üïê **Timezone:** {guild_tz_name}\\n\\n\"\n                    f\"üìÅ **Delivery:** ZIP file containing individual CSV for each employee\",\n                    file=zip_discord_file,\n                    ephemeral=True\n                )\n            \n        except (discord.NotFound, discord.errors.NotFound):\n            # Interaction expired or was deleted - silently handle this\n            print(f\"‚ö†Ô∏è Reports interaction expired/not found for user {interaction.user.id}\")\n        except discord.errors.InteractionResponded:\n            # Interaction was already responded to - try followup\n            try:\n                await interaction.followup.send(\"‚ùå Reports interaction error. Please try again.\", ephemeral=True)\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Failed to send followup after InteractionResponded: {e}\")\n        except Exception as e:\n            # General error handling\n            print(f\"‚ùå Error in generate_reports callback: {e}\")\n            try:\n                if not interaction.response.is_done():\n                    await interaction.response.send_message(f\"‚ùå Error generating reports: {str(e)}\", ephemeral=True)\n                else:\n                    await interaction.followup.send(f\"‚ùå Error generating reports: {str(e)}\", ephemeral=True)\n            except Exception:\n                # If we can't even send an error message, just log it\n                print(f\"‚ùå Failed to send error message for generate_reports: {e}\")\n\n    async def show_upgrade(self, interaction: discord.Interaction):\n        \"\"\"Show upgrade options for free tier servers\"\"\"\n        if not interaction.guild:\n            await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n            return\n            \n        guild_id = interaction.guild.id\n        server_tier = get_server_tier(guild_id)\n        \n        # Only show for free tier\n        if server_tier != \"free\":\n            await send_reply(interaction, \"This server already has a subscription!\", ephemeral=True)\n            return\n        \n        embed = discord.Embed(\n            title=\"üöÄ Upgrade Your Server\",\n            description=\"Choose a plan that fits your team's needs:\",\n            color=discord.Color.orange()\n        )\n        \n        embed.add_field(\n            name=\"üíº Basic Plan - $5/month\",\n            value=\"‚Ä¢ Full team access to timeclock\\n\"\n                  \"‚Ä¢ All admin commands\\n\"\n                  \"‚Ä¢ CSV Reports\\n\"\n                  \"‚Ä¢ Role management\\n\"\n                  \"‚Ä¢ 7 days data retention\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"‚≠ê Pro Plan - $10/month\",\n            value=\"‚Ä¢ Everything in Basic\\n\"\n                  \"‚Ä¢ Extended CSV reports\\n\"\n                  \"‚Ä¢ Multiple manager notifications\\n\"\n                  \"‚Ä¢ 30 days data retention\\n\"\n                  \"‚Ä¢ Priority support\",\n            inline=True\n        )\n        \n        embed.add_field(\n            name=\"üîó How to Upgrade\",\n            value=\"Use `/upgrade basic` or `/upgrade pro` commands to get started with secure Stripe checkout!\",\n            inline=False\n        )\n        \n        await send_reply(interaction, embed=embed, ephemeral=True)\n\n\n@bot.event\nasync def on_ready():\n    # Persistent views are now registered in setup_hook (both new and legacy views)\n    # This ensures backward compatibility with existing posted messages\n    \n    # Debug: Check what commands are in the tree\n    commands = tree.get_commands()\n    print(f\"üìã Commands in tree: {len(commands)}\")\n    for cmd in commands:\n        description = getattr(cmd, 'description', 'No description')\n        print(f\"   - {cmd.name}: {description}\")\n    \n    # Try syncing commands with better error handling\n    synced_count = 0\n    sync_location = \"nowhere\"\n    \n    try:\n        if GUILD_ID:\n            # Try guild-specific sync first\n            try:\n                guild_obj = discord.Object(id=int(GUILD_ID))\n                synced = await tree.sync(guild=guild_obj)\n                synced_count = len(synced)\n                sync_location = f\"guild {GUILD_ID}\"\n                print(f\"‚úÖ Synced {synced_count} commands to guild {GUILD_ID}\")\n                \n                # If guild sync fails, try global\n                if synced_count == 0:\n                    print(\"üîÑ Guild sync returned 0 commands, trying global sync...\")\n                    synced = await tree.sync()\n                    synced_count = len(synced)\n                    sync_location = \"globally (after guild failed)\"\n                    print(f\"‚úÖ Global sync: {synced_count} commands\")\n                    \n            except Exception as guild_error:\n                print(f\"‚ùå Guild sync failed: {guild_error}\")\n                print(\"üîÑ Trying global sync as fallback...\")\n                # Fallback to global sync\n                synced = await tree.sync()\n                synced_count = len(synced)\n                sync_location = \"globally\"\n                print(f\"‚úÖ Synced {synced_count} commands globally (fallback)\")\n        else:\n            # No guild ID provided, sync globally\n            synced = await tree.sync()\n            synced_count = len(synced)\n            sync_location = \"globally\"\n            print(f\"‚úÖ Synced {synced_count} global commands\")\n            \n    except Exception as e:\n        print(f\"‚ùå All command sync attempts failed: {e}\")\n        synced_count = 0\n    \n    print(f\"üéØ Final result: {synced_count} commands synced {sync_location}\")\n    if bot.user:\n        print(f\"ü§ñ Logged in as {bot.user} ({bot.user.id})\")\n    else:\n        print(\"ü§ñ Bot user information not available\")\n    \n    # Update bot_guilds table with all connected guilds\n    try:\n        with db() as conn:\n            for guild in bot.guilds:\n                conn.execute(\"\"\"\n                    INSERT OR REPLACE INTO bot_guilds (guild_id, guild_name, joined_at)\n                    VALUES (?, ?, datetime('now'))\n                \"\"\", (str(guild.id), guild.name))\n        print(f\"‚úÖ Updated bot_guilds table with {len(bot.guilds)} guilds\")\n    except Exception as e:\n        print(f\"‚ùå Error updating bot_guilds table: {e}\")\n\n@bot.event\nasync def on_guild_join(guild):\n    \"\"\"Send welcome message with setup instructions when bot joins a new server\"\"\"\n    print(f\"üéâ Bot joined new server: {guild.name} (ID: {guild.id})\")\n    \n    # Try to find the person who added the bot (guild owner as fallback)\n    inviter = guild.owner\n    \n    # Create a fancy welcome embed\n    embed = discord.Embed(\n        title=\"‚è∞ Welcome to On the Clock!\",\n        description=\"Thanks for adding our professional Discord timeclock bot to your server!\",\n        color=discord.Color.blurple()\n    )\n    \n    # Add setup instructions\n    embed.add_field(\n        name=\"üöÄ Quick Setup\",\n        value=(\n            \"1Ô∏è‚É£ Run `/setup_timeclock` in your desired channel\\n\"\n            \"2Ô∏è‚É£ Configure role access with `/add_employee_role @role`\\n\"\n            \"3Ô∏è‚É£ Set admin roles with `/add_admin_role @role` (optional)\\n\"\n            \"4Ô∏è‚É£ Your team can start tracking time immediately!\"\n        ),\n        inline=False\n    )\n    \n    # Add access control explanation\n    embed.add_field(\n        name=\"üîê Access Control\",\n        value=(\n            \"**Timeclock functions:**\\n\"\n            \"‚Ä¢ Free tier: Admins only\\n\"\n            \"‚Ä¢ Basic/Pro tier: Any role you specify\\n\\n\"\n            \"**Reports/Upgrade buttons:**\\n\"\n            \"‚Ä¢ Discord Administrators\\n\"\n            \"‚Ä¢ Custom admin roles (via `/add_admin_role`)\"\n        ),\n        inline=False\n    )\n    \n    # Add subscription tier information\n    embed.add_field(\n        name=\"üíº Subscription Tiers\",\n        value=(\n            \"**üÜì Free (Current):** Admin-only access, sample reports\\n\"\n            \"**üíº Basic ($5/month):** Full team access, 7-day reports\\n\"\n            \"**‚≠ê Pro ($10/month):** Everything + 30-day reports\\n\\n\"\n            \"Use `/upgrade basic` or `/upgrade pro` to unlock full features!\"\n        ),\n        inline=False\n    )\n    \n    # Add feature highlights\n    embed.add_field(\n        name=\"‚ú® Key Features\",\n        value=(\n            \"‚Ä¢ One-click time tracking with Discord buttons\\n\"\n            \"‚Ä¢ Smart timezone support (EST/EDT by default)\\n\"\n            \"‚Ä¢ Professional CSV reports for payroll\\n\"\n            \"‚Ä¢ Real-time \\\"who's on the clock\\\" status\\n\"\n            \"‚Ä¢ Role-based access control\\n\"\n            \"‚Ä¢ Secure Stripe payment integration\"\n        ),\n        inline=False\n    )\n    \n    # Add footer with support info\n    embed.set_footer(\n        text=\"Need help? Contact support or check our documentation\",\n        icon_url=bot.user.avatar.url if bot.user and bot.user.avatar else None\n    )\n    \n    # Try to send the welcome message to the server owner\n    try:\n        if inviter:\n            await inviter.send(embed=embed)\n            print(f\"‚úÖ Sent welcome message to {inviter} in {guild.name}\")\n        else:\n            print(f\"‚ö†Ô∏è Could not find owner for {guild.name}\")\n    except discord.Forbidden:\n        print(f\"‚ùå Could not DM owner of {guild.name} - DMs disabled\")\n        # Try to send to system channel or first text channel as fallback\n        target_channel = guild.system_channel\n        if not target_channel:\n            # Find first text channel the bot can send to\n            for channel in guild.text_channels:\n                if channel.permissions_for(guild.me).send_messages:\n                    target_channel = channel\n                    break\n        \n        if target_channel:\n            try:\n                await target_channel.send(f\"üëã {inviter.mention}\" if inviter else \"üëã Hello!\", embed=embed)\n                print(f\"‚úÖ Sent welcome message to #{target_channel.name} in {guild.name}\")\n            except Exception as e:\n                print(f\"‚ùå Could not send welcome message anywhere in {guild.name}: {e}\")\n    except Exception as e:\n        print(f\"‚ùå Error sending welcome message for {guild.name}: {e}\")\n    \n    # Add guild to bot_guilds table\n    try:\n        with db() as conn:\n            conn.execute(\"\"\"\n                INSERT OR REPLACE INTO bot_guilds (guild_id, guild_name, joined_at)\n                VALUES (?, ?, datetime('now'))\n            \"\"\", (str(guild.id), guild.name))\n        print(f\"‚úÖ Added {guild.name} to bot_guilds table\")\n    except Exception as e:\n        print(f\"‚ùå Error adding guild to bot_guilds table: {e}\")\n\n@bot.event\nasync def on_guild_remove(guild):\n    \"\"\"Remove guild from bot_guilds table when bot leaves a server\"\"\"\n    print(f\"üëã Bot removed from server: {guild.name} (ID: {guild.id})\")\n    \n    try:\n        with db() as conn:\n            conn.execute(\"DELETE FROM bot_guilds WHERE guild_id = ?\", (str(guild.id),))\n        print(f\"‚úÖ Removed {guild.name} from bot_guilds table\")\n    except Exception as e:\n        print(f\"‚ùå Error removing guild from bot_guilds table: {e}\")\n\n@tree.command(name=\"setup\", description=\"View timeclock setup information and instructions\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def setup(interaction: discord.Interaction):\n    \"\"\"\n    Display timeclock setup information and instructions.\n    Shows how to use the universal /clock command system.\n    \"\"\"\n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        return\n    \n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await interaction.edit_original_response(content=\"‚ùå This command must be used in a server.\")\n        return\n    \n    try:\n        # Get server information\n        server_tier = get_server_tier(guild_id)\n        \n        if server_tier == \"free\":\n            access_info = \"**Free Tier:** Only administrators can use the timeclock\\n‚Ä¢ Upgrade to Basic/Pro for full team access\"\n        else:\n            access_info = \"**Team Access:** All configured employee roles can use the timeclock\"\n        \n        # Use the same domain detection as other functions\n        dashboard_url = f\"https://{get_domain()}\"\n        \n        setup_message = (\n            f\"‚è∞ **Timeclock Setup Complete!**\\n\\n\"\n            f\"**How to Use:**\\n\"\n            f\"‚Ä¢ Type `/clock` anywhere in the server to access timeclock\\n\"\n            f\"‚Ä¢ No channel setup needed - works from any channel!\\n\"\n            f\"‚Ä¢ Fresh interface every time - no timeout issues\\n\"\n            f\"‚Ä¢ All responses are private (only you see them)\\n\\n\"\n            f\"**Current Access Level:**\\n\"\n            f\"{access_info}\\n\\n\"\n            f\"**üìä Web Dashboard:**\\n\"\n            f\"‚Ä¢ Visit **{dashboard_url}** for advanced management\\n\"\n            f\"‚Ä¢ Login with Discord to view reports and settings\\n\"\n            f\"‚Ä¢ Access real-time server statistics and admin tools\\n\\n\"\n            f\"**Available Commands:**\\n\"\n            f\"‚Ä¢ `/clock` - Access your timeclock interface\\n\"\n            f\"‚Ä¢ `/help` - View all available commands\\n\"\n            f\"‚Ä¢ `/upgrade` - Upgrade your server plan\\n\\n\"\n            f\"**üéâ Setup Benefits:**\\n\"\n            f\"‚Ä¢ **Universal Access:** Works from any channel\\n\"\n            f\"‚Ä¢ **No Maintenance:** No buttons to refresh or manage\\n\"\n            f\"‚Ä¢ **Always Reliable:** Zero interaction failures\\n\"\n            f\"‚Ä¢ **Professional Experience:** Clean, private workflow\\n\\n\"\n            f\"**üÜò Need Help?** Join support: https://discord.gg/KdTRTqdPcj\"\n        )\n        \n        await interaction.edit_original_response(content=setup_message)\n        print(f\"‚úÖ Displayed setup information for guild {guild_id}\")\n        \n    except Exception as e:\n        print(f\"‚ùå Failed to display setup information: {e}\")\n        await interaction.edit_original_response(\n            content=\"‚ùå **Setup Information Error**\\n\\n\"\n                   \"Could not retrieve setup information.\\n\"\n                   \"Please try again or contact support if the issue persists.\"\n        )\n\n\n@tree.command(name=\"clock\", description=\"Access your personal timeclock interface\")\n@app_commands.guild_only()\nasync def clock_interface(interaction: discord.Interaction):\n    \"\"\"\n    Provides users with their personal timeclock interface.\n    Shows fresh buttons that never timeout - the new reliable way to clock in/out.\n    \"\"\"\n    # Check if user has permission to use timeclock\n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    \n    # Check if user has permission to use timeclock functions\n    server_tier = get_server_tier(guild_id)\n    \n    # Type guard: ensure we have a Member for guild-specific functions\n    if not isinstance(interaction.user, discord.Member):\n        await send_reply(interaction,\n            \"‚ùå Unable to verify access permissions. Please try again.\",\n            ephemeral=True\n        )\n        return\n    \n    if not user_has_clock_access(interaction.user, server_tier):\n        if server_tier == \"free\":\n            await send_reply(interaction,\n                \"‚ö†Ô∏è **Free Tier Limitation**\\n\\n\"\n                \"Only administrators can use timeclock functions on the free tier.\\n\"\n                \"Upgrade to Basic or Pro to unlock full team access!\\n\\n\"\n                \"Use `/upgrade` to see subscription options.\",\n                ephemeral=True\n            )\n        else:\n            await send_reply(interaction,\n                \"‚ùå **Access Denied**\\n\\n\"\n                \"You don't have permission to use timeclock functions.\\n\"\n                \"Contact your server administrator to:\\n\"\n                \"‚Ä¢ Add you to an employee role using `/add_employee_role`\\n\"\n                \"‚Ä¢ Or grant you administrator permissions\",\n                ephemeral=True\n            )\n        return\n    \n    # Create fresh timeclock interface for this user\n    try:\n        # Create a non-persistent view with fresh buttons (no timeout issues!)\n        view = TimeClockView(guild_id=guild_id)\n        \n        # Get current clock status for user\n        user_id = interaction.user.id\n        active_session = None\n        \n        with sqlite3.connect(DB_PATH) as conn:\n            cursor = conn.execute(\n                \"SELECT clock_in FROM sessions WHERE user_id = ? AND guild_id = ? AND clock_out IS NULL\",\n                (user_id, guild_id)\n            )\n            active_session = cursor.fetchone()\n        \n        # Build status message\n        if active_session:\n            clock_in_time = datetime.fromisoformat(active_session[0]).replace(tzinfo=timezone.utc)\n            elapsed = datetime.now(timezone.utc) - clock_in_time\n            hours, remainder = divmod(int(elapsed.total_seconds()), 3600)\n            minutes, _ = divmod(remainder, 60)\n            \n            status_message = (\n                f\"üü¢ **You're Currently Clocked In**\\n\\n\"\n                f\"**Started:** <t:{int(clock_in_time.timestamp())}:f>\\n\"\n                f\"**Elapsed Time:** {hours}h {minutes}m\\n\\n\"\n                f\"Use the buttons below to manage your time:\"\n            )\n        else:\n            status_message = (\n                f\"‚ö™ **Ready to Clock In**\\n\\n\"\n                f\"You're not currently clocked in.\\n\"\n                f\"Use the buttons below to start tracking your time:\"\n            )\n        \n        # Send ephemeral response with fresh buttons\n        await send_reply(interaction, \n            content=status_message,\n            view=view, \n            ephemeral=True\n        )\n        \n        print(f\"‚úÖ Provided fresh timeclock interface to {interaction.user} in guild {guild_id}\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error creating timeclock interface for {interaction.user}: {e}\")\n        await send_reply(interaction,\n            \"‚ùå **Error Creating Timeclock Interface**\\n\\n\"\n            \"Something went wrong while creating your timeclock interface.\\n\"\n            \"Please try again, or contact your administrator if the problem persists.\",\n            ephemeral=True\n        )\n\n@tree.command(name=\"set_recipient\", description=\"Set who receives private time entries (DMs)\")\n@app_commands.describe(user=\"Manager/admin who should receive time entries via DM\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def set_recipient(interaction: discord.Interaction, user: discord.User):\n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    set_guild_setting(guild_id, \"recipient_user_id\", user.id)\n    await send_reply(interaction, f\"‚úÖ Set recipient to {user.mention}.\", ephemeral=True)\n\n@tree.command(name=\"set_timezone\", description=\"Set display timezone (e.g., America/New_York)\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def set_timezone(interaction: discord.Interaction, tz: str):\n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    set_guild_setting(guild_id, \"timezone\", tz)\n    await send_reply(interaction, f\"‚úÖ Timezone set to `{tz}` (display only).\", ephemeral=True)\n\n@tree.command(name=\"toggle_name_display\", description=\"Toggle between username and nickname display\")\n@app_commands.describe(mode=\"Choose 'username' (Discord username) or 'nickname' (server display name)\")\n@app_commands.choices(mode=[\n    app_commands.Choice(name=\"Username (Discord username)\", value=\"username\"),\n    app_commands.Choice(name=\"Nickname (Server display name)\", value=\"nickname\")\n])\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def toggle_name_display(interaction: discord.Interaction, mode: app_commands.Choice[str]):\n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    set_guild_setting(guild_id, \"name_display_mode\", mode.value)\n    \n    if mode.value == \"username\":\n        await send_reply(interaction,\n            \"‚úÖ **Name Display Set to Username**\\n\"\n            \"The bot will now show Discord usernames (e.g., `john_doe`) in reports and messages.\",\n            ephemeral=True\n        )\n    else:\n        await send_reply(interaction,\n            \"‚úÖ **Name Display Set to Nickname**\\n\"\n            \"The bot will now show server display names (e.g., `John D.`) in reports and messages.\",\n            ephemeral=True\n        )\n\n\n\n@tree.command(name=\"add_admin_role\", description=\"Add a role that can access Reports and Upgrade buttons\")\n@app_commands.describe(role=\"Role to grant admin access (Reports, Upgrade buttons)\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def add_admin_role_cmd(interaction: discord.Interaction, role: discord.Role):\n    await interaction.response.defer(ephemeral=True)\n    \n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\")\n        return\n    add_admin_role(guild_id, role.id)\n    await interaction.followup.send(f\"‚úÖ Added {role.mention} to admin roles. They can now use Reports and Upgrade buttons.\")\n\n@tree.command(name=\"remove_admin_role\", description=\"Remove a role's admin access to Reports and Upgrade buttons\")\n@app_commands.describe(role=\"Role to remove admin access from\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def remove_admin_role_cmd(interaction: discord.Interaction, role: discord.Role):\n    await interaction.response.defer(ephemeral=True)\n    \n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\")\n        return\n    remove_admin_role(guild_id, role.id)\n    await interaction.followup.send(f\"‚úÖ Removed {role.mention} from admin roles. They can no longer use Reports and Upgrade buttons.\")\n\n@tree.command(name=\"list_admin_roles\", description=\"List all roles with admin access\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def list_admin_roles(interaction: discord.Interaction):\n    await interaction.response.defer(ephemeral=True)\n    \n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\")\n        return\n    \n    admin_role_ids = get_admin_roles(guild_id)\n    \n    embed = discord.Embed(\n        title=\"üõ°Ô∏è Admin Roles\",\n        description=\"Roles that can access Reports and Upgrade buttons:\",\n        color=discord.Color.blue()\n    )\n    \n    # Always show Administrator role first (permanent, cannot be removed)\n    embed.add_field(name=\"Built-in Admin Role\", value=\"@Admin (Discord Administrators)\", inline=False)\n    \n    # Show custom admin roles if any are configured\n    if admin_role_ids:\n        admin_roles = []\n        for role_id in admin_role_ids:\n            role = interaction.guild.get_role(role_id) if interaction.guild else None\n            if role:\n                admin_roles.append(role.mention)\n            else:\n                admin_roles.append(f\"<Deleted Role: {role_id}>\")\n        embed.add_field(name=\"Custom Admin Roles\", value=\"\\n\".join(admin_roles), inline=False)\n    else:\n        embed.add_field(name=\"Custom Admin Roles\", value=\"*No custom admin roles configured*\", inline=False)\n    \n    embed.add_field(name=\"Note\", value=\"Discord Administrators always have admin access.\", inline=False)\n    \n    await interaction.followup.send(embed=embed)\n\n@tree.command(name=\"set_main_role\", description=\"Set the primary admin role (gets all admin functions)\")\n@app_commands.describe(role=\"Role to designate as main admin (gets Reports, Upgrade, all admin access)\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def set_main_role(interaction: discord.Interaction, role: discord.Role):\n    \"\"\"Set the primary admin role that gets all admin functions\"\"\"\n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    set_guild_setting(guild_id, \"main_admin_role_id\", role.id)\n    \n    embed = discord.Embed(\n        title=\"üõ°Ô∏è Main Admin Role Set\",\n        description=f\"**{role.mention}** is now the main admin role for this server.\",\n        color=discord.Color.green()\n    )\n    embed.add_field(\n        name=\"What this means:\",\n        value=(\n            \"‚Ä¢ This role gets **all admin functions** (Reports, Upgrade, etc.)\\n\"\n            \"‚Ä¢ Works in addition to Discord Administrators\\n\"\n            \"‚Ä¢ Perfect for designating manager roles\\n\"\n            \"‚Ä¢ Useful for Top.gg reviewers and testing\"\n        ),\n        inline=False\n    )\n    embed.add_field(\n        name=\"Management:\",\n        value=\"Use `/show_main_role` to view or `/clear_main_role` to remove\",\n        inline=False\n    )\n    \n    await send_reply(interaction, embed=embed, ephemeral=True)\n\n@tree.command(name=\"show_main_role\", description=\"View the current main admin role\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def show_main_role(interaction: discord.Interaction):\n    \"\"\"Show the current main admin role\"\"\"\n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    \n    main_role_id = get_guild_setting(guild_id, \"main_admin_role_id\")\n    \n    if not main_role_id:\n        embed = discord.Embed(\n            title=\"üõ°Ô∏è Main Admin Role\",\n            description=\"No main admin role is currently set.\",\n            color=discord.Color.orange()\n        )\n        embed.add_field(\n            name=\"To set a main admin role:\",\n            value=\"Use `/set_main_role @role` to designate a role with all admin functions\",\n            inline=False\n        )\n    else:\n        role = interaction.guild.get_role(main_role_id) if interaction.guild else None\n        if role:\n            embed = discord.Embed(\n                title=\"üõ°Ô∏è Main Admin Role\",\n                description=f\"**{role.mention}** is the main admin role.\",\n                color=discord.Color.blue()\n            )\n            embed.add_field(\n                name=\"Permissions:\",\n                value=\"This role has access to all admin functions (Reports, Upgrade buttons, etc.)\",\n                inline=False\n            )\n        else:\n            embed = discord.Embed(\n                title=\"üõ°Ô∏è Main Admin Role\",\n                description=\"Main admin role was set but the role has been deleted.\",\n                color=discord.Color.red()\n            )\n            embed.add_field(\n                name=\"Fix this:\",\n                value=\"Use `/clear_main_role` to clear the invalid role, then `/set_main_role` to set a new one\",\n                inline=False\n            )\n    \n    await send_reply(interaction, embed=embed, ephemeral=True)\n\n@tree.command(name=\"clear_main_role\", description=\"Remove the main admin role designation\") \n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def clear_main_role(interaction: discord.Interaction):\n    \"\"\"Clear the main admin role\"\"\"\n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    \n    main_role_id = get_guild_setting(guild_id, \"main_admin_role_id\")\n    \n    if not main_role_id:\n        await send_reply(interaction,\n            \"No main admin role is currently set.\",\n            ephemeral=True\n        )\n        return\n    \n    # Get role name before clearing (if it exists)\n    role = interaction.guild.get_role(main_role_id) if interaction.guild else None\n    role_name = role.mention if role else f\"<Deleted Role: {main_role_id}>\"\n    \n    # Clear the main admin role\n    set_guild_setting(guild_id, \"main_admin_role_id\", None)\n    \n    embed = discord.Embed(\n        title=\"üõ°Ô∏è Main Admin Role Cleared\",\n        description=f\"**{role_name}** is no longer the main admin role.\",\n        color=discord.Color.green()\n    )\n    embed.add_field(\n        name=\"Current Admin Access:\",\n        value=(\n            \"‚Ä¢ Discord Administrators (always have access)\\n\"\n            \"‚Ä¢ Custom admin roles (if any set via `/add_admin_role`)\"\n        ),\n        inline=False\n    )\n    \n    await send_reply(interaction, embed=embed, ephemeral=True)\n\n@tree.command(name=\"add_employee_role\", description=\"Add a role that can use timeclock functions\")\n@app_commands.describe(role=\"Role to grant employee access (timeclock functions)\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def add_employee_role_cmd(interaction: discord.Interaction, role: discord.Role):\n    await interaction.response.defer(ephemeral=True)\n    \n    guild_id = interaction.guild_id\n    if guild_id is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\")\n        return\n    add_employee_role(guild_id, role.id)\n    server_tier = get_server_tier(guild_id)\n    \n    # Provide helpful context based on server tier\n    if server_tier == \"free\":\n        message = f\"‚úÖ Added {role.mention} to employee roles.\\nüéâ **Employee roles work on free tier!** Only limitation is shorter data retention compared to paid plans.\"\n    else:\n        message = f\"‚úÖ Added {role.mention} to employee roles. Members with this role can now use timeclock functions.\"\n    \n    await interaction.followup.send(message)\n\n@tree.command(name=\"remove_employee_role\", description=\"Remove a role's access to timeclock functions\")\n@app_commands.describe(role=\"Role to remove employee access from\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def remove_employee_role_cmd(interaction: discord.Interaction, role: discord.Role):\n    await interaction.response.defer(ephemeral=True)\n    \n    if interaction.guild_id is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\")\n        return\n    remove_employee_role(interaction.guild_id, role.id)\n    await interaction.followup.send(f\"‚úÖ Removed {role.mention} from employee roles. They can no longer use timeclock functions (unless admin).\")\n\n@tree.command(name=\"list_employee_roles\", description=\"List all roles that can use timeclock functions\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def list_employee_roles(interaction: discord.Interaction):\n    await interaction.response.defer(ephemeral=True)\n    \n    if interaction.guild_id is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\")\n        return\n    clock_role_ids = get_employee_roles(interaction.guild_id)\n    server_tier = get_server_tier(interaction.guild_id)\n    \n    embed = discord.Embed(\n        title=\"üë• Employee Access Roles\",\n        description=\"Roles that can use timeclock functions:\",\n        color=discord.Color.green()\n    )\n    \n    # Always show Administrator role first (permanent, cannot be removed)\n    embed.add_field(name=\"Built-in Employee Access\", value=\"@Admin (Discord Administrators)\", inline=False)\n    \n    # Show custom employee roles if any are configured\n    if clock_role_ids:\n        employee_roles = []\n        if interaction.guild:  # Additional null check for LSP\n            for role_id in clock_role_ids:\n                role = interaction.guild.get_role(role_id)\n                if role:\n                    employee_roles.append(role.mention)\n                else:\n                    employee_roles.append(f\"<Deleted Role: {role_id}>\")\n        \n        embed.add_field(name=\"Custom Employee Roles\", value=\"\\n\".join(employee_roles), inline=False)\n        \n        if server_tier == \"free\":\n            embed.add_field(name=\"‚ö†Ô∏è Free Tier Limitation\", value=\"These roles are configured but won't take effect until you upgrade to Basic/Pro. Currently only admins can use timeclock functions.\", inline=False)\n    else:\n        if server_tier == \"free\":\n            embed.add_field(name=\"Custom Employee Roles\", value=\"*No custom employee roles configured.*\\nUpgrade to Basic/Pro to configure roles for team access!\", inline=False)\n        else:\n            embed.add_field(name=\"Custom Employee Roles\", value=\"*No custom employee roles configured.*\\nUse `/add_employee_role @role` to grant access to your team!\", inline=False)\n    \n    embed.add_field(name=\"Note\", value=\"Administrators always have timeclock access regardless of role configuration.\", inline=False)\n    \n    await interaction.followup.send(embed=embed)\n\n\n@tree.command(name=\"help\", description=\"List all available slash commands\")\n@app_commands.guild_only()\nasync def help_command(interaction: discord.Interaction):\n    if interaction.guild_id is None:\n        await send_reply(interaction, \"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n    # Get current server tier\n    server_tier = get_server_tier(interaction.guild_id)\n    tier_color = {\"free\": discord.Color.green(), \"basic\": discord.Color.blue(), \"pro\": discord.Color.purple()}\n    \n    embed = discord.Embed(\n        title=\"üìã Complete Command Reference\",\n        description=f\"**Current Plan:** {server_tier.title()}\\n\\n**All available slash commands organized by function:**\",\n        color=tier_color.get(server_tier, discord.Color.green())\n    )\n    \n    # Version 1.1 Update Notice\n    embed.add_field(\n        name=\"üéâ Version 1.1 - No More Timeouts!\",\n        value=(\n            \"**New `/clock` Command:** Access your timeclock interface with fresh buttons every time!\\n\"\n            \"**No More Issues:** Say goodbye to timeout errors and refresh commands\\n\"\n            \"**Easy to Use:** Just type `/clock` whenever you need to punch in or out\"\n        ),\n        inline=False\n    )\n    \n    # Core Timeclock Commands (new section)\n    embed.add_field(\n        name=\"‚è∞ Timeclock Commands\",\n        value=(\n            \"`/clock` - Access your personal timeclock interface (fresh buttons, never times out!)\\n\"\n            \"`/setup` - View timeclock setup information and instructions\"\n        ),\n        inline=False\n    )\n    \n    # Setup & Configuration Commands\n    embed.add_field(\n        name=\"‚öôÔ∏è Setup & Configuration\",\n        value=(\n            \"`/set_recipient <user>` - Set who receives private time entries (DMs)\\n\"\n            \"`/set_timezone <timezone>` - Set display timezone (e.g., America/New_York)\\n\"\n            \"`/toggle_name_display` - Toggle between username and nickname display\\n\"\n            \"`/help` - List all available slash commands\"\n        ),\n        inline=False\n    )\n    \n    # Admin Role Management Commands\n    embed.add_field(\n        name=\"üë§ Admin Role Management\",\n        value=(\n            \"`/add_admin_role <role>` - Add a role that can access Reports and Upgrade buttons\\n\"\n            \"`/remove_admin_role <role>` - Remove a role's admin access to Reports and Upgrade buttons\\n\"\n            \"`/list_admin_roles` - List all roles with admin access\\n\"\n            \"`/set_main_role <role>` - Set the primary admin role (gets all admin functions)\\n\"\n            \"`/show_main_role` - View the current main admin role\\n\"\n            \"`/clear_main_role` - Remove the main admin role designation\"\n        ),\n        inline=False\n    )\n    \n    # Employee Role Management Commands\n    embed.add_field(\n        name=\"üë• Employee Role Management\",\n        value=(\n            \"`/add_employee_role <role>` - Add a role that can use timeclock functions\\n\"\n            \"`/remove_employee_role <role>` - Remove a role's access to timeclock functions\\n\"\n            \"`/list_employee_roles` - List all roles that can use timeclock functions\"\n        ),\n        inline=False\n    )\n    \n    # Reports & Data Management Commands\n    embed.add_field(\n        name=\"üìä Reports & Data Management\",\n        value=(\n            \"`/report <user> <start_date> <end_date>` - Generate CSV timesheet report for individual user\\n\"\n            \"`/data_cleanup` - Manually trigger data cleanup (Admin only)\\n\"\n            \"`/purge` - Permanently delete timeclock data (preserves subscription)\"\n        ),\n        inline=False\n    )\n    \n    # Subscription Management Commands\n    embed.add_field(\n        name=\"üí≥ Subscription Management\",\n        value=(\n            \"`/upgrade` - Upgrade your server to Basic or Pro plan\\n\"\n            \"`/cancel_subscription` - Learn how to cancel your subscription\\n\"\n            \"`/subscription_status` - View current subscription status\"\n        ),\n        inline=False\n    )\n    \n    # Tier Information & Features\n    tier_info = \"\\n\\n**Plan Features:**\\n\"\n    if server_tier == \"free\":\n        tier_info += (\n            \"üÜì **Free Tier:** Admin-only testing ‚Ä¢ Sample reports ‚Ä¢ Employee roles configured but inactive\\n\"\n            \"üí° **Upgrade Benefits:** Basic ($5/mo) unlocks full team access & real CSV reports\"\n        )\n    elif server_tier == \"basic\":\n        tier_info += (\n            \"üíô **Basic Tier:** Full team access ‚Ä¢ Real CSV reports ‚Ä¢ 7-day data retention\\n\"\n            \"üí° **Pro Benefits:** 30-day retention ‚Ä¢ Multiple manager notifications ‚Ä¢ Extended features\"\n        )\n    else:  # pro tier\n        tier_info += \"üíú **Pro Tier:** All features unlocked ‚Ä¢ 30-day retention ‚Ä¢ Multiple managers ‚Ä¢ Priority support\"\n    \n    embed.add_field(\n        name=\"üîò How to Use Your Timeclock\",\n        value=(\n            \"**Step 1:** Type `/clock` to access your personal timeclock\\n\"\n            \"**Step 2:** Use the fresh buttons that appear (only you see them)\\n\"\n            \"‚Ä¢ üü¢ **Clock In** - Start tracking your time\\n\"\n            \"‚Ä¢ üî¥ **Clock Out** - Stop tracking and log your shift\\n\"\n            \"‚Ä¢ üìä **Reports** - Generate timesheet reports (admin access)\\n\"\n            \"‚Ä¢ ‚¨ÜÔ∏è **Upgrade** - Upgrade to Basic/Pro plans\\n\" + \n            tier_info\n        ),\n        inline=False\n    )\n    \n    # Version 1.1 Benefits & Info\n    embed.add_field(\n        name=\"‚ú® Version 1.1 Benefits\",\n        value=(\n            \"üö´ **No More Timeouts:** Fresh buttons every time you use `/clock`\\n\"\n            \"‚ö° **Always Works:** Zero maintenance, no refresh commands needed\\n\"\n            \"üîí **Private Interface:** Only you see your timeclock responses\\n\"\n            \"üéØ **Reliable:** Never fails, never times out, always available\"\n        ),\n        inline=False\n    )\n    \n    embed.set_footer(text=f\"üí° {server_tier.title()} Plan Active | Type /clock to access your timeclock!\")\n    \n    await send_reply(interaction, embed=embed, ephemeral=True)\n\n@tree.command(name=\"report\", description=\"Generate CSV timesheet report for individual user\")\n@app_commands.describe(\n    user=\"Select user to generate report for\",\n    start_date=\"Start date (YYYY-MM-DD format)\",\n    end_date=\"End date (YYYY-MM-DD format)\"\n)\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def generate_report(\n    interaction: discord.Interaction, \n    user: discord.Member,\n    start_date: str,\n    end_date: str\n):\n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    # Check tier access for reports\n    if interaction.guild is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n        \n    guild_id = interaction.guild.id\n    server_tier = get_server_tier(guild_id)\n    \n    # Type guard: ensure we have a Member for guild-specific functions\n    if not isinstance(interaction.user, discord.Member):\n        await interaction.followup.send(\n            \"‚ùå Unable to verify admin permissions. Please try again.\",\n            ephemeral=True\n        )\n        return\n    \n    # Free tier: Admin only + fake data\n    if server_tier == \"free\":\n        if not user_has_admin_access(interaction.user):\n            await interaction.followup.send(\n                \"üîí **Free Tier Limitation**\\n\"\n                \"Only server administrators can test the report feature.\\n\"\n                \"Upgrade to Basic ($5/month) for full team access and CSV reports!\",\n                ephemeral=True\n            )\n            return\n        \n        # Return fake CSV for free tier\n        fake_csv = \"Date,Clock In,Clock Out,Duration\\n2024-01-01,09:00,17:00,8.0 hours\\nThis is the free version, please upgrade for more options\"\n        user_display_name = get_user_display_name(user, guild_id)\n        filename = f\"{user_display_name}_sample_report_{start_date}_to_{end_date}.csv\"\n        \n        file = discord.File(\n            io.BytesIO(fake_csv.encode('utf-8')), \n            filename=filename\n        )\n        await interaction.followup.send(\n            f\"üìä **Free Tier Sample Report** for **{user_display_name}**\\n\"\n            f\"üéØ This is sample data. Upgrade to Basic ($5/month) or Pro ($10/month) for real reports!\\n\"\n            f\"üìÖ Date Range: {start_date} to {end_date}\",\n            file=file,\n            ephemeral=True\n        )\n        return\n    \n    # Basic and Pro tier: Full reports access with retention limits\n    # Get tier limits\n    tier_limits = {\"basic\": 7, \"pro\": 30}\n    max_days = tier_limits.get(server_tier, 30)\n    \n    try:\n        # Validate date format and order\n        start_dt = datetime.strptime(start_date, \"%Y-%m-%d\")\n        end_dt = datetime.strptime(end_date, \"%Y-%m-%d\")\n        \n        if start_dt > end_dt:\n            await interaction.followup.send(\n                \"‚ùå Start date must be before or equal to end date\", \n                ephemeral=True\n            )\n            return\n        \n        # Check retention limits for Basic tier\n        days_requested = (end_dt - start_dt).days + 1\n        if days_requested > max_days:\n            await interaction.followup.send(\n                f\"‚ùå **{server_tier.title()} tier limitation**: Reports limited to {max_days} days maximum.\\n\"\n                f\"You requested {days_requested} days. Please choose a shorter date range.\\n\\n\"\n                f\"üí° Upgrade to Pro for extended 30-day reports!\" if server_tier == \"basic\" else \"\",\n                ephemeral=True\n            )\n            return\n            \n    except ValueError:\n        await interaction.followup.send(\n            \"‚ùå Invalid date format. Please use YYYY-MM-DD (e.g., 2024-01-15)\", \n            ephemeral=True\n        )\n        return\n    \n    # Get guild timezone (guild_id already checked above)\n    guild_tz_name = get_guild_setting(guild_id, \"timezone\", DEFAULT_TZ)\n    \n    # Convert date range to UTC boundaries for proper filtering\n    try:\n        from zoneinfo import ZoneInfo\n        guild_tz = ZoneInfo(guild_tz_name or DEFAULT_TZ)\n    except Exception:\n        guild_tz = timezone.utc\n        guild_tz_name = \"UTC\"  # Use actual UTC if timezone is invalid\n    \n    # Create start and end boundaries in guild timezone, then convert to UTC\n    start_boundary = datetime.combine(start_dt.date(), datetime.min.time()).replace(tzinfo=guild_tz)\n    end_boundary = datetime.combine(end_dt.date(), datetime.max.time()).replace(tzinfo=guild_tz)\n    \n    start_utc = start_boundary.astimezone(timezone.utc).isoformat()\n    end_utc = end_boundary.astimezone(timezone.utc).isoformat()\n    \n    # Generate report for specific user (guild_id already checked above)\n    user_id = user.id\n    sessions_data = get_sessions_report(guild_id, user_id, start_utc, end_utc)\n    \n    if not sessions_data:\n        user_display_name = get_user_display_name(user, guild_id)\n        await interaction.followup.send(\n            f\"üì≠ No completed timesheet entries found for **{user_display_name}** between {start_date} and {end_date}\",\n            ephemeral=True\n        )\n        return\n    \n    # Generate single CSV\n    csv_content = await generate_csv_report(bot, sessions_data, guild_id, guild_tz_name or DEFAULT_TZ)\n    \n    # Create file using display name preference at the beginning\n    user_display_name = get_user_display_name(user, guild_id)\n    filename = f\"{user_display_name}_timesheet_report_{start_date}_to_{end_date}.csv\"\n    \n    file = discord.File(\n        io.BytesIO(csv_content.encode('utf-8')), \n        filename=filename\n    )\n    \n    # Send file\n    total_entries = len(sessions_data)\n    \n    await interaction.followup.send(\n        f\"üìä Generated timesheet report for **{user_display_name}**\\n\"\n        f\"üìÖ **Period:** {start_date} to {end_date}\\n\"\n        f\"üìù **Entries:** {total_entries} completed shifts\\n\"\n        f\"üïê **Timezone:** {guild_tz_name}\",\n        file=file,\n        ephemeral=True\n    )\n    \n    # Also send email reports to configured email recipients\n    try:\n        recipients = get_report_recipients(guild_id)\n        email_recipients = [r for r in recipients if r[1] == 'email' and r[3]]  # recipient_type == 'email' and email_address exists\n        \n        if email_recipients:\n            email_addresses = [r[3] for r in email_recipients]  # Extract email addresses\n            \n            try:\n                guild_name = interaction.guild.name if interaction.guild else f\"Server-{guild_id}\"\n                report_period = f\"{start_date} to {end_date} - {user_display_name}\"\n                \n                # Send email report to all email recipients\n                result = await send_timeclock_report_email(\n                    to=email_addresses,\n                    guild_name=guild_name,\n                    csv_content=csv_content,\n                    report_period=report_period\n                )\n                \n                print(f\"‚úÖ Email report sent to {len(email_addresses)} recipients for {user_display_name}\")\n                \n            except Exception as email_error:\n                print(f\"‚ùå Failed to send email report: {email_error}\")\n                \n    except Exception as e:\n        print(f\"‚ö†Ô∏è Email report delivery attempt failed: {e}\")\n\n# --- Scheduled Tasks ---\ndef schedule_daily_cleanup():\n    \"\"\"Schedule daily cleanup task\"\"\"\n    def daily_cleanup():\n        # Wait 60 seconds after startup before first cleanup attempt\n        threading.Event().wait(60)\n        \n        while True:\n            try:\n                # Run cleanup\n                deleted_count = cleanup_old_sessions()\n                if deleted_count > 0:\n                    print(f\"üßπ Daily cleanup: Removed {deleted_count} old session records\")\n                \n                # Sleep for 24 hours\n                threading.Event().wait(86400)  # 24 hours in seconds\n            except sqlite3.OperationalError as e:\n                if \"locked\" in str(e).lower():\n                    print(f\"‚è≥ Database locked during daily cleanup, skipping this cycle: {e}\")\n                    threading.Event().wait(3600)  # Wait 1 hour before retrying\n                else:\n                    print(f\"‚ùå Database error during daily cleanup: {e}\")\n                    threading.Event().wait(3600)  # Wait 1 hour before retrying\n            except Exception as e:\n                print(f\"‚ùå Error during daily cleanup: {e}\")\n                threading.Event().wait(3600)  # Wait 1 hour before retrying\n    \n    cleanup_thread = threading.Thread(target=daily_cleanup, daemon=True)\n    cleanup_thread.start()\n    print(\"‚è∞ Daily cleanup scheduler started\")\n\n@tree.command(name=\"data_cleanup\", description=\"Manually trigger data cleanup (Admin only)\")\n@app_commands.describe(user=\"Optional: Delete all timeclock data for a specific server member only\")\n@app_commands.default_permissions(administrator=True)  \n@app_commands.guild_only()\nasync def manual_cleanup(interaction: discord.Interaction, user: Optional[discord.Member] = None):\n    \"\"\"Allow admins to manually trigger data cleanup - either for old sessions or for a specific user\"\"\"\n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n        \n    try:\n        \n        if interaction.guild is None:\n            await interaction.followup.send(\"Use this in a server.\", ephemeral=True)\n            return\n            \n        guild_id = interaction.guild.id\n        \n        if user:\n            # Delete all data for the specific user\n            deleted_count = cleanup_user_sessions(guild_id, user.id)\n            \n            embed = discord.Embed(\n                title=\"üóëÔ∏è User Data Cleanup Complete\",\n                color=discord.Color.green()\n            )\n            embed.add_field(name=\"Target User\", value=f\"{user.mention} ({user.name})\", inline=True)\n            embed.add_field(name=\"Records Removed\", value=f\"{deleted_count} sessions\", inline=True)\n            embed.add_field(\n                name=\"‚ö†Ô∏è Action Performed\",\n                value=f\"All timeclock data for **{user.name}** has been permanently deleted from this server.\",\n                inline=False\n            )\n            \n        else:\n            # Clean up old sessions based on retention policy\n            deleted_count = cleanup_old_sessions(guild_id)\n            retention_days = get_retention_days(guild_id)\n            tier = get_server_tier(guild_id)\n            \n            embed = discord.Embed(\n                title=\"üßπ Data Cleanup Complete\",\n                color=discord.Color.green()\n            )\n            embed.add_field(name=\"Records Removed\", value=f\"{deleted_count} old sessions\", inline=True)\n            embed.add_field(name=\"Current Tier\", value=f\"{tier.title()}\", inline=True)\n            embed.add_field(name=\"Data Retention\", value=f\"{retention_days} days\", inline=True)\n            embed.add_field(\n                name=\"Retention Policy\",\n                value=\"**Free:** No retention (test only)\\n**Basic:** 7 days (1 week)\\n**Pro:** 30 days (1 month)\",\n                inline=False\n            )\n        \n        await interaction.followup.send(embed=embed, ephemeral=True)\n        \n    except (discord.NotFound, discord.errors.NotFound):\n        # Interaction expired or was deleted - silently handle this\n        print(f\"‚ö†Ô∏è Data cleanup interaction expired/not found for user {interaction.user.id}\")\n    except discord.errors.InteractionResponded:\n        # Interaction was already responded to - try followup\n        try:\n            await interaction.followup.send(\"‚ùå Cleanup interaction error. Please try again.\", ephemeral=True)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Failed to send followup after InteractionResponded: {e}\")\n    except Exception as e:\n        # General error handling\n        print(f\"‚ùå Error in data_cleanup command: {e}\")\n        try:\n            if not interaction.response.is_done():\n                await interaction.response.send_message(f\"‚ùå Error during cleanup: {str(e)}\", ephemeral=True)\n            else:\n                await interaction.followup.send(f\"‚ùå Error during cleanup: {str(e)}\", ephemeral=True)\n        except Exception:\n            # If we can't even send an error message, just log it\n            print(f\"‚ùå Failed to send error message for data_cleanup: {e}\")\n\nclass PurgeConfirmationView(discord.ui.View):\n    \"\"\"Confirmation view for purge command\"\"\"\n    def __init__(self, guild_id: int):\n        super().__init__(timeout=60.0)  # 60 second timeout\n        self.guild_id = guild_id\n        self.confirmed = False\n    \n    @discord.ui.button(label=\"‚úÖ Yes, Purge Timeclock Data\", style=discord.ButtonStyle.danger, custom_id=\"purge_yes\")\n    async def confirm_purge(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Handle purge confirmation\"\"\"\n        # Robust defer with proper fallback\n        defer_success = await robust_defer(interaction, ephemeral=True)\n        if not defer_success and not interaction.response.is_done():\n            # If defer failed and interaction isn't done, we can't proceed\n            return\n        \n        # Check if user is a Member (should be in guild context) and has admin access\n        if not isinstance(interaction.user, discord.Member) or not user_has_admin_access(interaction.user):\n            await interaction.followup.send(\"‚ùå Only administrators can use this command.\", ephemeral=True)\n            return\n        \n        try:\n            # Use standalone purge function\n            purge_timeclock_data_only(self.guild_id)\n            \n            embed = discord.Embed(\n                title=\"üóëÔ∏è Timeclock Data Purge Complete\",\n                description=\"All timeclock sessions have been permanently removed.\",\n                color=discord.Color.green()\n            )\n            embed.add_field(\n                name=\"What was removed:\",\n                value=\"‚Ä¢ All time clock sessions (all users, all dates)\",\n                inline=False\n            )\n            embed.add_field(\n                name=\"What was preserved:\",\n                value=\"‚Ä¢ Subscription status remains unchanged\\n‚Ä¢ Server settings kept intact\\n‚Ä¢ Role permissions preserved\",\n                inline=False\n            )\n            embed.add_field(\n                name=\"‚ö†Ô∏è This action cannot be undone\",\n                value=\"Your timeclock history has been cleared, but your subscription and settings remain active.\",\n                inline=False\n            )\n            \n            await interaction.followup.send(embed=embed, ephemeral=True)\n            self.confirmed = True\n            \n            # Disable all buttons\n            for item in self.children:\n                if isinstance(item, discord.ui.Button):\n                    item.disabled = True\n            \n        except Exception as e:\n            await interaction.followup.send(f\"‚ùå Error during purge: {str(e)}\", ephemeral=True)\n    \n    @discord.ui.button(label=\"‚ùå Cancel\", style=discord.ButtonStyle.secondary, custom_id=\"purge_no\")\n    async def cancel_purge(self, interaction: discord.Interaction, button: discord.ui.Button):\n        \"\"\"Handle purge cancellation\"\"\"\n        embed = discord.Embed(\n            title=\"‚úÖ Purge Cancelled\",\n            description=\"No timeclock data was removed. Your server data remains intact.\",\n            color=discord.Color.green()\n        )\n        \n        await interaction.response.edit_message(embed=embed, view=None)\n    \n    async def on_timeout(self):\n        \"\"\"Handle timeout\"\"\"\n        # Disable all buttons when timeout occurs\n        for item in self.children:\n            if isinstance(item, discord.ui.Button):\n                item.disabled = True\n\n@tree.command(name=\"purge\", description=\"Permanently delete timeclock data (preserves subscription)\")\n@app_commands.default_permissions(administrator=True)  \n@app_commands.guild_only()\nasync def purge_data(interaction: discord.Interaction):\n    \"\"\"Allow admins to manually purge timeclock data only\"\"\"\n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    if interaction.guild is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n        \n    guild_id = interaction.guild.id\n    \n    # Type guard: ensure we have a Member for guild-specific functions\n    if not isinstance(interaction.user, discord.Member):\n        await interaction.followup.send(\n            \"‚ùå Unable to verify admin permissions. Please try again.\",\n            ephemeral=True\n        )\n        return\n    \n    # Double-check admin status\n    if not is_server_admin(interaction.user):\n        await interaction.followup.send(\"‚ùå Only server administrators can use this command.\", ephemeral=True)\n        return\n    \n    # Create warning embed\n    embed = discord.Embed(\n        title=\"‚ö†Ô∏è WARNING: Timeclock Data Purge\",\n        description=\"This will **permanently delete ALL timeclock sessions**!\",\n        color=discord.Color.orange()\n    )\n    embed.add_field(\n        name=\"What will be deleted:\",\n        value=\"‚Ä¢ **All time clock sessions** (all users, all dates)\",\n        inline=False\n    )\n    embed.add_field(\n        name=\"What will be preserved:\",\n        value=(\n            \"‚Ä¢ **Subscription status** (Basic/Pro plans remain active)\\n\"\n            \"‚Ä¢ **Server settings** (timezone, recipients, etc.)\\n\"\n            \"‚Ä¢ **Role permissions** for buttons\"\n        ),\n        inline=False\n    )\n    embed.add_field(\n        name=\"‚ö†Ô∏è THIS CANNOT BE UNDONE\",\n        value=\"All historical timeclock data will be permanently lost.\",\n        inline=False\n    )\n    \n    # Create confirmation view\n    view = PurgeConfirmationView(guild_id)\n    \n    await interaction.followup.send(embed=embed, view=view, ephemeral=True)\n\n# --- Subscription Management Commands ---\n@tree.command(name=\"upgrade\", description=\"Upgrade your server to Basic or Pro plan\")\n@app_commands.describe(plan=\"Choose Basic ($5/month) or Pro ($10/month)\")\n@app_commands.choices(plan=[\n    app_commands.Choice(name=\"Basic - $5/month\", value=\"basic\"),\n    app_commands.Choice(name=\"Pro - $10/month\", value=\"pro\")\n])\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def upgrade_server(interaction: discord.Interaction, plan: str):\n    \"\"\"Create Stripe checkout link for server upgrade\"\"\"\n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    if interaction.guild is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n        \n    guild_id = interaction.guild.id\n    \n    try:\n        current_tier = get_server_tier(guild_id)\n        \n        # Check if already on this tier or higher\n        tier_hierarchy = {'free': 0, 'basic': 1, 'pro': 2}\n        if tier_hierarchy.get(current_tier, 0) >= tier_hierarchy.get(plan, 0):\n            await interaction.followup.send(\n                f\"‚úÖ Your server is already on **{current_tier.title()}** plan or higher!\\n\"\n                f\"Use `/subscription_status` to view current subscription details.\",\n                ephemeral=True\n            )\n            return\n        \n        # Check Stripe configuration\n        if not stripe.api_key:\n            await interaction.followup.send(\n                \"‚ùå Payment system is not configured. Please contact support.\",\n                ephemeral=True\n            )\n            return\n        \n        # Create secure checkout session server-side\n        checkout_url = create_secure_checkout_session(guild_id, plan)\n        \n        plan_details = {\n            'basic': \"**Basic Plan - $5/month**\\n‚Ä¢ Full team access to timeclock\\n‚Ä¢ All admin commands\\n‚Ä¢ CSV Reports\\n‚Ä¢ Role management\\n‚Ä¢ 1 week data retention\",\n            'pro': \"**Pro Plan - $10/month**\\n‚Ä¢ Everything in Basic\\n‚Ä¢ Extended CSV reports\\n‚Ä¢ Multiple manager notifications\\n‚Ä¢ 30 days data retention\"\n        }\n        \n        embed = discord.Embed(\n            title=f\"üí≥ Upgrade to {plan.title()} Plan\",\n            description=plan_details[plan],\n            color=discord.Color.blue()\n        )\n        embed.add_field(\n            name=\"Next Steps\",\n            value=f\"Click the button below to complete your upgrade through Stripe.\\n\"\n                  f\"You'll be redirected to a secure checkout page.\",\n            inline=False\n        )\n        \n        # Create a view with a button that opens the checkout URL\n        view = discord.ui.View()\n        button = discord.ui.Button(\n            label=f\"Upgrade to {plan.title()} - ${5 if plan == 'basic' else 10}/month\",\n            style=discord.ButtonStyle.primary,\n            url=checkout_url\n        )\n        view.add_item(button)\n        \n        await interaction.followup.send(embed=embed, view=view, ephemeral=True)\n        \n    except Exception as e:\n        await interaction.followup.send(\n            f\"‚ùå Error creating checkout session: {str(e)}\", \n            ephemeral=True\n        )\n\n@tree.command(name=\"cancel_subscription\", description=\"Learn how to cancel your subscription\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def cancel_subscription(interaction: discord.Interaction):\n    \"\"\"Provide instructions for canceling subscription\"\"\"\n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    if interaction.guild is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n        \n    guild_id = interaction.guild.id\n    \n    try:\n        # Check current subscription status\n        current_tier = get_server_tier(guild_id)\n        \n        if current_tier == \"free\":\n            embed = discord.Embed(\n                title=\"üìã Subscription Information\",\n                description=\"Your server is currently on the **Free** plan and has no active subscription to cancel.\",\n                color=discord.Color.green()\n            )\n            \n            embed.add_field(\n                name=\"Current Status\",\n                value=\"‚úÖ No subscription - No action needed\",\n                inline=False\n            )\n            \n            embed.add_field(\n                name=\"Want to upgrade?\",\n                value=\"Use `/upgrade basic` or `/upgrade pro` to start a subscription\",\n                inline=False\n            )\n            \n        else:\n            embed = discord.Embed(\n                title=\"üö® How to Cancel Your Subscription\",\n                description=f\"Your server is currently on the **{current_tier.title()}** plan. Here's how to cancel:\",\n                color=discord.Color.red()\n            )\n            \n            embed.add_field(\n                name=\"Step 1: Access Stripe Customer Portal\",\n                value=\"Visit [Stripe Customer Portal](https://billing.stripe.com/p/login) and log in with the email used for payment\",\n                inline=False\n            )\n            \n            embed.add_field(\n                name=\"Step 2: Find Your Subscription\",\n                value=\"Look for your 'On the Clock Discord Bot' subscription in your billing dashboard\",\n                inline=False\n            )\n            \n            embed.add_field(\n                name=\"Step 3: Cancel Subscription\",\n                value=\"Click 'Cancel subscription' and follow the prompts to confirm cancellation\",\n                inline=False\n            )\n            \n            embed.add_field(\n                name=\"‚ö†Ô∏è IMPORTANT: Data Deletion Warning\",\n                value=\"**When you cancel your subscription, ALL DATA will be permanently deleted:**\\n\" +\n                      \"‚Ä¢ All timeclock sessions and history\\n\" +\n                      \"‚Ä¢ Guild settings and configurations\\n\" +\n                      \"‚Ä¢ Role permissions and authorizations\\n\" +\n                      \"‚Ä¢ CSV reports and exports\\n\" +\n                      \"\\n**This action cannot be undone!**\",\n                inline=False\n            )\n            \n            embed.add_field(\n                name=\"üìÖ When Does Deletion Happen?\",\n                value=\"Data deletion occurs immediately upon subscription cancellation. Your server will be downgraded to Free tier.\",\n                inline=False\n            )\n            \n            embed.add_field(\n                name=\"üíæ Want to Keep Your Data?\",\n                value=\"Before canceling, use the **Reports** button to export and save your timeclock data as CSV files.\",\n                inline=False\n            )\n            \n            embed.add_field(\n                name=\"üîÑ Need Help?\",\n                value=\"Contact our support if you need assistance with cancellation or have questions about data retention.\",\n                inline=False\n            )\n        \n        await interaction.followup.send(embed=embed, ephemeral=True)\n        \n    except Exception as e:\n        await interaction.followup.send(\n            f\"‚ùå Error fetching cancellation information: {str(e)}\", \n            ephemeral=True\n        )\n\n@tree.command(name=\"subscription_status\", description=\"View current subscription status\")\n@app_commands.default_permissions(administrator=True)\n@app_commands.guild_only()\nasync def subscription_status(interaction: discord.Interaction):\n    \"\"\"Show current subscription tier and details\"\"\"\n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    if interaction.guild is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n        \n    guild_id = interaction.guild.id\n    \n    try:\n        with db() as conn:\n            cursor = conn.execute(\"\"\"\n                SELECT tier, subscription_id, customer_id, expires_at, status\n                FROM server_subscriptions \n                WHERE guild_id = ?\n            \"\"\", (guild_id,))\n            result = cursor.fetchone()\n            \n            if not result:\n                tier = \"free\"\n                subscription_id = None\n                customer_id = None\n                expires_at = None\n                status = \"active\"\n            else:\n                tier, subscription_id, customer_id, expires_at, status = result\n        \n        tier_colors = {\"free\": discord.Color.green(), \"basic\": discord.Color.blue(), \"pro\": discord.Color.purple()}\n        tier_emojis = {\"free\": \"üÜì\", \"basic\": \"üíº\", \"pro\": \"‚≠ê\"}\n        \n        embed = discord.Embed(\n            title=f\"{tier_emojis.get(tier, '‚ùì')} Subscription Status\",\n            color=tier_colors.get(tier, discord.Color.greyple())\n        )\n        \n        embed.add_field(name=\"Current Plan\", value=tier.title(), inline=True)\n        embed.add_field(name=\"Status\", value=status.title(), inline=True)\n        \n        if subscription_id:\n            embed.add_field(name=\"Subscription ID\", value=f\"`{subscription_id}`\", inline=True)\n        \n        if expires_at:\n            embed.add_field(name=\"Next Billing\", value=f\"<t:{int(datetime.fromisoformat(expires_at).timestamp())}:f>\", inline=True)\n        \n        # Show plan features\n        plan_features = {\n            'free': \"‚Ä¢ Admin-only testing\\n‚Ä¢ Sample reports\\n‚Ä¢ No data retention\",\n            'basic': \"‚Ä¢ Full team access\\n‚Ä¢ All admin commands\\n‚Ä¢ CSV Reports\\n‚Ä¢ Role management\\n‚Ä¢ 1 week data retention\",\n            'pro': \"‚Ä¢ Everything in Basic\\n‚Ä¢ Extended CSV reports\\n‚Ä¢ Multiple managers\\n‚Ä¢ 30 days data retention\"\n        }\n        \n        embed.add_field(\n            name=\"Plan Features\",\n            value=plan_features.get(tier, \"Unknown plan\"),\n            inline=False\n        )\n        \n        # Show upgrade options for lower tiers\n        if tier == \"free\":\n            embed.add_field(\n                name=\"Upgrade Options\",\n                value=\"Use `/upgrade basic` or `/upgrade pro` to upgrade your server!\",\n                inline=False\n            )\n        elif tier == \"basic\":\n            embed.add_field(\n                name=\"Upgrade Option\",\n                value=\"Use `/upgrade pro` to upgrade to Pro plan!\",\n                inline=False\n            )\n        \n        await interaction.followup.send(embed=embed, ephemeral=True)\n        \n    except Exception as e:\n        await interaction.followup.send(\n            f\"‚ùå Error fetching subscription status: {str(e)}\", \n            ephemeral=True\n        )\n\n# =============================================================================\n# OWNER-ONLY SUPER ADMIN COMMANDS (Only visible to bot owner)\n# =============================================================================\n\n@tree.command(name=\"owner_grant\", description=\"[OWNER] Grant subscription tier to current server\")\n@app_commands.describe(tier=\"Subscription tier to grant\")\n@app_commands.choices(tier=[\n    app_commands.Choice(name=\"Basic ($5/month)\", value=\"basic\"),\n    app_commands.Choice(name=\"Pro ($10/month)\", value=\"pro\")\n])\nasync def owner_grant_tier(interaction: discord.Interaction, tier: str):\n    \"\"\"Owner-only command to grant subscription tiers\"\"\"\n    if interaction.user.id != BOT_OWNER_ID:\n        await send_reply(interaction, \"‚ùå Access denied.\", ephemeral=True)\n        return\n        \n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    if interaction.guild is None:\n        await interaction.followup.send(\"‚ùå This command must be used in a server.\", ephemeral=True)\n        return\n        \n    guild_id = interaction.guild.id\n    guild_name = interaction.guild.name\n    \n    try:\n        # Check current tier\n        current_tier = get_server_tier(guild_id)\n        \n        # Grant the new tier (no Stripe subscription - manual owner grant)\n        set_server_tier(guild_id, tier, subscription_id=f\"owner_grant_{int(time.time())}\", customer_id=\"owner_manual\")\n        \n        embed = discord.Embed(\n            title=\"üëë Owner Grant Successful\",\n            description=f\"Manually granted **{tier.title()}** tier to this server\",\n            color=discord.Color.gold()\n        )\n        \n        embed.add_field(name=\"Server\", value=guild_name, inline=True)\n        embed.add_field(name=\"Server ID\", value=str(guild_id), inline=True)\n        embed.add_field(name=\"Previous Tier\", value=current_tier.title(), inline=True)\n        embed.add_field(name=\"New Tier\", value=tier.title(), inline=True)\n        embed.add_field(name=\"Granted By\", value=\"Bot Owner (Manual)\", inline=True)\n        embed.add_field(name=\"Type\", value=\"Owner Override\", inline=True)\n        \n        embed.add_field(\n            name=\"Features Unlocked\",\n            value=\"‚Ä¢ Full team access\\n‚Ä¢ CSV Reports\\n‚Ä¢ Role management\\n‚Ä¢ Extended retention\" if tier == \"pro\" else \"‚Ä¢ Full team access\\n‚Ä¢ CSV Reports\\n‚Ä¢ Role management\\n‚Ä¢ 7-day retention\",\n            inline=False\n        )\n        \n        await interaction.followup.send(embed=embed, ephemeral=True)\n        \n    except Exception as e:\n        await interaction.followup.send(f\"‚ùå Error granting tier: {str(e)}\", ephemeral=True)\n\n\n@tree.command(name=\"owner_grant_server\", description=\"[OWNER] Grant subscription to any server by ID\")\n@app_commands.describe(\n    server_id=\"Discord server ID to grant subscription to\",\n    tier=\"Subscription tier to grant\"\n)\n@app_commands.choices(tier=[\n    app_commands.Choice(name=\"Basic ($5/month)\", value=\"basic\"),\n    app_commands.Choice(name=\"Pro ($10/month)\", value=\"pro\")\n])\nasync def owner_grant_server_by_id(interaction: discord.Interaction, server_id: str, tier: str):\n    \"\"\"Owner-only command to grant subscriptions to any server by ID\"\"\"\n    if interaction.user.id != BOT_OWNER_ID:\n        await send_reply(interaction, \"‚ùå Access denied.\", ephemeral=True)\n        return\n        \n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    try:\n        # Validate server ID\n        try:\n            guild_id = int(server_id)\n        except ValueError:\n            await interaction.followup.send(\"‚ùå Invalid server ID format.\", ephemeral=True)\n            return\n        \n        # Try to get guild info (if bot is in that server)\n        guild = bot.get_guild(guild_id)\n        guild_name = guild.name if guild else f\"Server ID: {guild_id}\"\n        \n        # Check if bot is in the server\n        if not guild:\n            await interaction.followup.send(f\"‚ö†Ô∏è Bot is not in server {guild_id}. Grant will still be applied if server adds bot later.\", ephemeral=True)\n        \n        # Check current tier\n        current_tier = get_server_tier(guild_id)\n        \n        # Grant the tier\n        set_server_tier(guild_id, tier, subscription_id=f\"owner_remote_{int(time.time())}\", customer_id=\"owner_remote\")\n        \n        embed = discord.Embed(\n            title=\"üåê Remote Server Grant Successful\",\n            description=f\"Granted **{tier.title()}** tier to remote server\",\n            color=discord.Color.purple()\n        )\n        \n        embed.add_field(name=\"Target Server\", value=guild_name, inline=True)\n        embed.add_field(name=\"Server ID\", value=str(guild_id), inline=True)\n        embed.add_field(name=\"Bot Present\", value=\"‚úÖ Yes\" if guild else \"‚ùå No\", inline=True)\n        embed.add_field(name=\"Previous Tier\", value=current_tier.title(), inline=True)\n        embed.add_field(name=\"New Tier\", value=tier.title(), inline=True)\n        embed.add_field(name=\"Grant Type\", value=\"Remote Owner Override\", inline=True)\n        \n        if guild:\n            embed.add_field(name=\"Member Count\", value=str(guild.member_count), inline=True)\n            embed.add_field(name=\"Server Owner\", value=str(guild.owner), inline=True)\n        \n        embed.add_field(\n            name=\"Status\",\n            value=\"‚úÖ Subscription active immediately\" if guild else \"‚è≥ Will activate when bot joins server\",\n            inline=False\n        )\n        \n        await interaction.followup.send(embed=embed, ephemeral=True)\n        \n    except Exception as e:\n        await interaction.followup.send(f\"‚ùå Error granting remote server subscription: {str(e)}\", ephemeral=True)\n\n@tree.command(name=\"owner_server_listings\", description=\"[OWNER] View all servers with employee/admin headcounts\")\nasync def owner_server_listings(interaction: discord.Interaction):\n    \"\"\"Owner-only command to list all servers with employee/admin headcounts\"\"\"\n    if interaction.user.id != BOT_OWNER_ID:\n        await send_reply(interaction, \"‚ùå Access denied.\", ephemeral=True)\n        return\n        \n    # Robust defer with proper fallback\n    defer_success = await robust_defer(interaction, ephemeral=True)\n    if not defer_success and not interaction.response.is_done():\n        # If defer failed and interaction isn't done, we can't proceed\n        return\n    \n    try:\n        embed = discord.Embed(\n            title=\"üìä Server Listings\",\n            description=f\"Bot is active in {len(bot.guilds)} servers\",\n            color=discord.Color.blue()\n        )\n        \n        server_data = []\n        \n        for guild in bot.guilds:\n            # Get server tier\n            tier = get_server_tier(guild.id)\n            \n            # Note: Without member intents, we can't count individual users by permissions/roles\n            # We can only provide the total member count and role configuration info\n            admin_count = \"N/A*\"\n            employee_count = \"N/A*\"\n            \n            # Check if clock roles are configured (indicates employees beyond admins)\n            employee_roles = get_employee_roles(guild.id)\n            employee_setup = \"Admin-only\" if not employee_roles else f\"{len(employee_roles)} employee roles\"\n            \n            server_data.append({\n                'name': guild.name,\n                'id': guild.id,\n                'member_count': guild.member_count,\n                'admin_count': admin_count,\n                'employee_count': employee_count,\n                'employee_setup': employee_setup,\n                'tier': tier\n            })\n        \n        # Sort by member count (largest first)\n        server_data.sort(key=lambda x: x['member_count'], reverse=True)\n        \n        # Add server info to embed (limit to prevent message too long)\n        for i, server in enumerate(server_data[:15]):  # Show first 15 servers\n            tier_emoji = {\"free\": \"üÜì\", \"basic\": \"üíº\", \"pro\": \"‚≠ê\"}.get(server['tier'], \"‚ùì\")\n            \n            embed.add_field(\n                name=f\"{tier_emoji} {server['name'][:30]}\" + (\"...\" if len(server['name']) > 30 else \"\"),\n                value=f\"**Members:** {server['member_count']}\\n\"\n                      f\"**Access:** {server['employee_setup']}\\n\"\n                      f\"**Tier:** {server['tier'].title()}\",\n                inline=True\n            )\n        \n        if len(server_data) > 15:\n            embed.add_field(\n                name=\"...\",\n                value=f\"And {len(server_data) - 15} more servers\",\n                inline=False\n            )\n        \n        # Add summary\n        total_members = sum(s['member_count'] for s in server_data)\n        admin_only_count = len([s for s in server_data if s['employee_setup'] == 'Admin-only'])\n        role_configured_count = len([s for s in server_data if s['employee_setup'] != 'Admin-only'])\n        \n        embed.add_field(\n            name=\"üìà Totals\",\n            value=f\"**Servers:** {len(server_data)}\\n\"\n                  f\"**Total Members:** {total_members:,}\\n\"\n                  f\"**Admin-Only Access:** {admin_only_count} servers\\n\"\n                  f\"**Employee Roles Setup:** {role_configured_count} servers\",\n            inline=False\n        )\n        \n        embed.add_field(\n            name=\"‚ÑπÔ∏è Note\",\n            value=\"*Individual admin/employee counts require member intents to be enabled in Discord Developer Portal*\",\n            inline=False\n        )\n        \n        await interaction.followup.send(embed=embed, ephemeral=True)\n        \n    except Exception as e:\n        await interaction.followup.send(f\"‚ùå Error fetching server listings: {str(e)}\", ephemeral=True)\n\n\nif __name__ == \"__main__\":\n    # Run database migrations first with exclusive locking\n    print(\"üîß Running database migrations...\")\n    run_migrations()\n    \n    # Initialize database tables\n    init_db()\n    \n    if not TOKEN:\n        raise SystemExit(\"Set DISCORD_TOKEN in your environment.\")\n    \n    # Health check server disabled - Flask app handles web server\n    # health_thread = threading.Thread(target=start_health_server, daemon=True)\n    # health_thread.start()\n    print(f\"‚úÖ Health check server disabled (Flask app handles web server)\")\n    \n    # Start daily cleanup scheduler\n    schedule_daily_cleanup()\n    \n    # Start Discord bot (this will block)\n    print(f\"ü§ñ Starting Discord bot...\")\n    bot.run(TOKEN)\n","size_bytes":250787},"replit.md":{"content":"# Overview\n\n\"On the Clock 1.5\" is a professional Discord timeclock bot for businesses. It provides subscription management, robust error handling, and enterprise-grade reliability. Key features include a three-tier subscription model (Free/Basic/Pro), Stripe payment integration, role-based access control, and a simple, unauthenticated landing page. The project aims to offer an easy-to-use time tracking solution for Discord communities.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Bot Framework\n- **Technology**: Discord.py (version 2.3+)\n- **Language**: Python 3.x\n- **Architecture Pattern**: Event-driven bot architecture.\n\n## Design Decisions\n- **Discord.py**: Chosen for its features, active development, and community support.\n- **Event-Driven Design**: Leverages async/await for concurrent event processing.\n- **Timezone Awareness**: Ensures correct time handling using `tzdata`.\n- **UI/UX**: Simple, static landing page without authentication; dashboard provides server-specific settings.\n- **Subscription Management**: Three-tier system (Free, Basic, Pro) with varying data retention (0, 7, 30 days).\n- **Concurrent Safety**: Utilizes guild-level locking, WAL mode for SQLite, and exclusive database migrations.\n- **Ephemeral Interface System**: Resolves interaction timeout issues by providing new interfaces via the `/clock` command.\n- **Server Settings Page**: Tile-based layout for role management, email settings (placeholder), and timezone controls, protected by Discord OAuth and requiring admin access.\n- **Custom Jinja2 Permission Filter**: Addresses Jinja2's lack of bitwise operator support for Discord permission checking.\n- **Secure Error Handling**: Generic user-facing messages, detailed server-side logging, and redaction of sensitive information.\n- **Database-Backed Sessions**: Ensures session persistence across restarts.\n\n## Security Configuration\n- **Code Analysis**: Semgrep rules for static analysis and secret management.\n- **Stripe Security**: Webhook signature verification and secure API key management.\n- **Data Privacy**: Automated data purging based on subscription tier and cancellation.\n- **Input Validation**: Robust validation for roles and timezones to prevent invalid data.\n- **Authorization Checks**: Bot presence and user admin access verified before operations.\n\n# External Dependencies\n\n## Core Libraries\n- **discord.py**: Primary library for Discord API interaction.\n- **tzdata**: Provides timezone data for Python.\n- **aiosqlite**: Asynchronous SQLite database interface.\n\n## Development Tools\n- **Semgrep**: Static analysis security scanner.\n\n## Discord Integration\n- **Discord API**: For real-time communication and operations.\n- **Discord OAuth 2.0**: For secure user authentication and dashboard features.\n\n## Payment Integration\n- **Stripe**: Handles subscriptions and payments, processing `checkout.session.completed` and `customer.subscription.deleted` webhooks.\n\n## Database\n- **SQLite**: Used for data storage with WAL mode enabled.\n- **Synchronized Database Path**: Both `bot.py` and `app.py` use `DB_PATH = os.getenv(\"TIMECLOCK_DB\", \"timeclock.db\")` to ensure they connect to the same database file. This prevents data isolation between Discord commands and web dashboard.\n\n# Server Settings Page Implementation\n\n**Date**: September 30, 2025  \n**Status**: ‚úÖ Implemented and Reviewed\n\n## Overview\n\nThe server settings page (`/server/<guild_id>/settings`) provides server admins with a centralized interface to manage server-specific configurations. Features include role management for admins and employees, email notification settings (placeholder), and timezone configuration.\n\n## Architecture\n\n### Flask Route: `/server/<guild_id>/settings`\n\n**Location**: `app.py` starting at line 556\n\n**Security & Authorization**:\n1. Bot presence check via `bot_guilds` table (404 if bot not in server)\n2. User authorization via `verify_guild_access()` (403 if not Owner/Administrator)\n3. Discord OAuth session validation via `@require_auth` decorator\n\n**Data Loading**:\n- Fetches guild roles from Discord API using bot token\n- Retrieves current settings from database (admin_roles, employee_roles, timezone)\n- Gracefully handles API failures with user-friendly error messages\n\n### Helper Functions\n\n**`get_guild_roles_from_bot(guild_id)`** (app.py line 473):\n- Fetches roles via Discord API with 5-second timeout\n- Handles 403 Forbidden and 404 Not Found errors\n- Returns list of role dictionaries or None on failure\n\n**`get_guild_settings(guild_id)`** (app.py line 509):\n- Retrieves admin roles, employee roles, timezone, and other settings\n- Defaults: timezone = \"America/New_York\", emails = []\n- Returns structured dictionary\n\n**`validate_role_in_guild(guild_id, role_id)`** (app.py line 620):\n- Validates role_id belongs to guild (prevents bogus data)\n- Uses Discord API to verify role exists in guild\n- Returns False on errors or invalid roles\n\n### API Endpoints\n\n**Authentication**: All use `@require_api_auth` decorator (returns JSON 401/403 instead of HTML redirects)\n\n**Admin Role Management**:\n- `POST /api/server/<guild_id>/admin-roles/add` (app.py line 631)\n  - Validates role belongs to guild before insertion\n  - Uses `INSERT OR IGNORE` to prevent duplicates\n  - Response: `{success: true, message: \"...\", role_id: \"...\"}`\n\n- `POST /api/server/<guild_id>/admin-roles/remove` (app.py line 663)\n  - Removes admin role from database\n  - Response: `{success: true, message: \"...\", role_id: \"...\"}`\n\n**Employee Role Management**:\n- `POST /api/server/<guild_id>/employee-roles/add` (app.py line 690)\n- `POST /api/server/<guild_id>/employee-roles/remove` (app.py line 722)\n- Same validation and response format as admin roles\n\n**Timezone Management**:\n- `POST /api/server/<guild_id>/timezone` (app.py line 763)\n  - Validates timezone against IANA database (zoneinfo)\n  - Handles INSERT and UPDATE cases\n  - Response: `{success: true, message: \"...\", timezone: \"...\"}`\n\n**Error Responses**: Consistent JSON format\n```json\n{\n  \"success\": false,\n  \"error\": \"Error message\"\n}\n```\n\n### UI Components (server_settings.html)\n\n**Tile 1: Admin Roles Management**\n- Dual listbox: Available Roles ‚Üî Current Admin Roles\n- Pre-populated from database\n- Transfer buttons call API endpoints\n\n**Tile 2: Employee Roles Management**\n- Dual listbox: Available Roles ‚Üî Current Employee Roles\n- Pre-populated from database\n- Transfer buttons call API endpoints\n\n**Tile 3: Email Settings**\n- Email input and listbox (placeholder - no email table yet)\n- Toggle switches: DM notifications, Email notifications\n- \"Customize Email\" button (future feature)\n\n**Tile 4: Timezone Settings**\n- Dropdown with all IANA timezones\n- Defaults to America/New_York\n- Pre-selects current timezone from database\n- Save button triggers API call\n\n### JavaScript Integration (server_settings.html, inline script)\n\n**Features**:\n- Role selection handlers for both tiles\n- Fetch API with async/await and error handling\n- Parses JSON responses and checks `response.ok` && `data.success`\n- Displays server error messages via alert()\n- Page reloads after successful changes\n\n## Security Features\n\n### API Authentication\n- `require_api_auth` decorator (app.py line 263)\n- Returns JSON 401/403 instead of redirects\n- Prevents misleading UX from HTML responses in fetch() calls\n- Clears expired sessions automatically\n\n### Input Validation\n- **Role Validation**: All role endpoints validate role_id belongs to guild\n- **Timezone Validation**: Validates against IANA database (zoneinfo.available_timezones())\n- Returns 400 Bad Request for invalid inputs\n\n### Authorization\n- Bot presence verified before operations\n- User admin access verified for all endpoints\n- Consistent 403 responses for unauthorized access\n\n### Error Handling\n- Generic user messages (no sensitive info exposed)\n- Detailed server logging with tracebacks\n- Consistent JSON error responses\n\n## Testing Procedures\n\n**Manual Testing** (requires Discord OAuth login):\n\n1. Navigate to server settings from dashboard\n2. Test admin role add/remove operations\n3. Test employee role add/remove operations\n4. Test timezone update and persistence\n5. Verify database changes:\n   ```sql\n   SELECT * FROM admin_roles WHERE guild_id = '<guild_id>';\n   SELECT * FROM employee_roles WHERE guild_id = '<guild_id>';\n   SELECT timezone FROM guild_settings WHERE guild_id = '<guild_id>';\n   ```\n6. Test error cases (invalid role_id, unauthorized access, bot not in server)\n\n## Known Limitations\n\n1. **Email Management**: Email table not yet implemented - Tile 3 is placeholder UI\n2. **Real-time Updates**: Role changes require page reload\n3. **Discord API Dependency**: Role validation requires live Discord API access\n\n## Future Enhancements\n\n- Email table and storage implementation\n- Real-time updates without page reload (WebSocket/AJAX)\n- Bulk role management operations\n- Role search/filter for large servers\n- Subscription tier-based feature gating per tile\n- Audit log for settings changes","size_bytes":9024},"email_utils.py":{"content":"# Email utility for On the Clock Discord Bot\n# Based on Replit Mail integration (blueprint:replitmail)\n\nimport os\nimport json\nimport base64\nimport asyncio\nimport aiohttp\nfrom typing import List, Dict, Optional, Union\nfrom datetime import datetime\n\nclass ReplitMailSender:\n    \"\"\"Email utility using Replit's OpenInt mail service\"\"\"\n    \n    def __init__(self):\n        self.api_endpoint = \"https://connectors.replit.com/api/v2/mailer/send\"\n        self.auth_token = self._get_auth_token()\n    \n    def _get_auth_token(self) -> str:\n        \"\"\"Get authentication token from environment variables\"\"\"\n        # Check for REPL_IDENTITY first (repl environment)\n        repl_identity = os.getenv('REPL_IDENTITY')\n        if repl_identity:\n            return f\"repl {repl_identity}\"\n        \n        # Check for WEB_REPL_RENEWAL (deployed environment)\n        web_repl_renewal = os.getenv('WEB_REPL_RENEWAL')\n        if web_repl_renewal:\n            return f\"depl {web_repl_renewal}\"\n        \n        raise ValueError(\n            \"No authentication token found. Please set REPL_IDENTITY or ensure you're running in Replit environment.\"\n        )\n    \n    async def send_email(\n        self,\n        to: Union[str, List[str]],\n        subject: str,\n        text: Optional[str] = None,\n        html: Optional[str] = None,\n        cc: Optional[Union[str, List[str]]] = None,\n        attachments: Optional[List[Dict]] = None\n    ) -> Dict:\n        \"\"\"\n        Send email using Replit's mail service\n        \n        Args:\n            to: Recipient email address(es)\n            subject: Email subject\n            text: Plain text body (optional)\n            html: HTML body (optional)  \n            cc: CC recipient email address(es) (optional)\n            attachments: List of attachments (optional)\n                Each attachment should be a dict with:\n                - filename: str\n                - content: str (base64 encoded)\n                - contentType: str (optional)\n                - encoding: str (default: \"base64\")\n        \n        Returns:\n            Dict with response from mail service\n        \"\"\"\n        \n        # Validate inputs\n        if not to:\n            raise ValueError(\"Recipient email address is required\")\n        if not subject:\n            raise ValueError(\"Email subject is required\")\n        if not text and not html:\n            raise ValueError(\"Either text or html body is required\")\n        \n        # Prepare payload\n        payload = {\n            \"to\": to,\n            \"subject\": subject\n        }\n        \n        if text:\n            payload[\"text\"] = text\n        if html:\n            payload[\"html\"] = html\n        if cc:\n            payload[\"cc\"] = cc\n        if attachments:\n            payload[\"attachments\"] = attachments\n        \n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"X_REPLIT_TOKEN\": self.auth_token\n        }\n        \n        async with aiohttp.ClientSession() as session:\n            try:\n                async with session.post(\n                    self.api_endpoint,\n                    headers=headers,\n                    json=payload\n                ) as response:\n                    \n                    if response.status != 200:\n                        error_text = await response.text()\n                        try:\n                            error_data = json.loads(error_text)\n                            error_message = error_data.get('message', 'Failed to send email')\n                        except:\n                            error_message = f\"HTTP {response.status}: {error_text}\"\n                        raise Exception(f\"Email send failed: {error_message}\")\n                    \n                    result = await response.json()\n                    return result\n                    \n            except aiohttp.ClientError as e:\n                raise Exception(f\"Network error sending email: {str(e)}\")\n\n    async def send_timeclock_report(\n        self,\n        to: Union[str, List[str]],\n        guild_name: str,\n        csv_content: str,\n        report_period: str\n    ) -> Dict:\n        \"\"\"\n        Send timeclock report with CSV attachment\n        \n        Args:\n            to: Recipient email address(es)\n            guild_name: Name of the Discord server\n            csv_content: CSV report content as string\n            report_period: Description of the report period\n        \n        Returns:\n            Dict with response from mail service\n        \"\"\"\n        \n        # Encode CSV content to base64\n        csv_base64 = base64.b64encode(csv_content.encode('utf-8')).decode('utf-8')\n        \n        # Generate filename with timestamp\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        filename = f\"timeclock_report_{guild_name}_{timestamp}.csv\"\n        \n        # Prepare email content\n        subject = f\"Timeclock Report - {guild_name} ({report_period})\"\n        \n        text_content = f\"\"\"\nTimeclock Report for {guild_name}\n\nReport Period: {report_period}\nGenerated: {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}\n\nPlease find the attached CSV file containing the timeclock data.\n\n---\nOn the Clock Discord Bot\n        \"\"\".strip()\n        \n        html_content = f\"\"\"\n<html>\n<body>\n    <h2>Timeclock Report for {guild_name}</h2>\n    \n    <p><strong>Report Period:</strong> {report_period}</p>\n    <p><strong>Generated:</strong> {datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}</p>\n    \n    <p>Please find the attached CSV file containing the timeclock data.</p>\n    \n    <hr>\n    <p><em>On the Clock Discord Bot</em></p>\n</body>\n</html>\n        \"\"\".strip()\n        \n        # Prepare attachment\n        attachments = [{\n            \"filename\": filename,\n            \"content\": csv_base64,\n            \"contentType\": \"text/csv\",\n            \"encoding\": \"base64\"\n        }]\n        \n        return await self.send_email(\n            to=to,\n            subject=subject,\n            text=text_content,\n            html=html_content,\n            attachments=attachments\n        )\n\n# Global email sender instance\nemail_sender = ReplitMailSender()\n\n# Convenience functions for easy import\nasync def send_email(to: Union[str, List[str]], subject: str, text: Optional[str] = None, html: Optional[str] = None) -> Dict:\n    \"\"\"Send a simple email\"\"\"\n    return await email_sender.send_email(to=to, subject=subject, text=text, html=html)\n\nasync def send_timeclock_report_email(to: Union[str, List[str]], guild_name: str, csv_content: str, report_period: str) -> Dict:\n    \"\"\"Send timeclock report with CSV attachment\"\"\"\n    return await email_sender.send_timeclock_report(to=to, guild_name=guild_name, csv_content=csv_content, report_period=report_period)","size_bytes":6691},"app.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nFlask app for On the Clock - landing page and OAuth dashboard.\n\"\"\"\nimport os\nimport secrets\nimport json\nimport sqlite3\nimport logging\nimport traceback\nfrom datetime import datetime, timedelta, timezone\nfrom urllib.parse import urlencode\nimport requests\nfrom flask import Flask, render_template, redirect, request, session, jsonify, url_for\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\napp = Flask(__name__)\n\n# Configure logging to work with Gunicorn\nif __name__ != '__main__':\n    gunicorn_logger = logging.getLogger('gunicorn.error')\n    app.logger.handlers = gunicorn_logger.handlers\n    app.logger.setLevel(gunicorn_logger.level)\nelse:\n    logging.basicConfig(level=logging.DEBUG)\n\n# Custom Jinja2 filter for Discord permission checking\n@app.template_filter('has_permission')\ndef has_permission(permissions, permission_flag):\n    \"\"\"Check if a permission integer has a specific flag using bitwise AND\"\"\"\n    try:\n        return int(permissions) & permission_flag != 0\n    except (ValueError, TypeError):\n        return False\napp.secret_key = os.environ.get('SECRET_KEY', secrets.token_hex(32))\napp.config['SESSION_COOKIE_SECURE'] = os.environ.get('FLASK_ENV') == 'production'\napp.config['SESSION_COOKIE_HTTPONLY'] = True\napp.config['SESSION_COOKIE_SAMESITE'] = 'Lax'\n\n# Fix for Replit reverse proxy - ensures correct scheme/host detection and client IP\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1, x_for=1)\n\n# Database Configuration - MUST match bot.py for proper synchronization\nDB_PATH = os.getenv(\"TIMECLOCK_DB\", \"timeclock.db\")\n\n# Discord OAuth2 Configuration\nDISCORD_CLIENT_ID = os.environ.get('DISCORD_CLIENT_ID')\nDISCORD_CLIENT_SECRET = os.environ.get('DISCORD_CLIENT_SECRET')\nDISCORD_API_BASE = 'https://discord.com/api/v10'\nDISCORD_OAUTH_SCOPES = 'identify guilds'\n\ndef get_redirect_uri():\n    \"\"\"Get redirect URI dynamically based on current request or environment\"\"\"\n    # Use environment variable if set, otherwise compute from current request\n    env_uri = os.environ.get('DISCORD_REDIRECT_URI')\n    if env_uri:\n        return env_uri\n    # Fallback: compute from current request (forces HTTPS for production)\n    return url_for('auth_callback', _external=True, _scheme='https')\n\n# Database connection\ndef get_db():\n    \"\"\"\n    Get database connection with same PRAGMA settings as bot.py\n    for proper synchronization between Discord bot and web dashboard\n    \"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    conn.execute(\"PRAGMA foreign_keys = ON\")\n    conn.execute(\"PRAGMA journal_mode = WAL\")\n    conn.execute(\"PRAGMA busy_timeout = 5000\")\n    conn.execute(\"PRAGMA synchronous = NORMAL\")\n    return conn\n\ndef init_dashboard_tables():\n    \"\"\"Initialize database tables for OAuth and user sessions\"\"\"\n    with get_db() as conn:\n        # OAuth states table for CSRF protection\n        conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS oauth_states (\n                state TEXT PRIMARY KEY,\n                expires_at TEXT NOT NULL\n            )\n        \"\"\")\n        \n        # User sessions table for logged-in users\n        conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS user_sessions (\n                session_id TEXT PRIMARY KEY,\n                user_id TEXT NOT NULL,\n                username TEXT NOT NULL,\n                discriminator TEXT,\n                avatar TEXT,\n                access_token TEXT NOT NULL,\n                refresh_token TEXT,\n                guilds_data TEXT NOT NULL,\n                created_at TEXT NOT NULL DEFAULT (datetime('now')),\n                expires_at TEXT NOT NULL,\n                ip_address TEXT NOT NULL DEFAULT 'unknown'\n            )\n        \"\"\")\n        \n        # Migration: Add refresh_token column if it doesn't exist\n        try:\n            conn.execute(\"ALTER TABLE user_sessions ADD COLUMN refresh_token TEXT\")\n        except sqlite3.OperationalError:\n            pass\n        \n        # Migration: Add created_at column if it doesn't exist\n        try:\n            conn.execute(\"ALTER TABLE user_sessions ADD COLUMN created_at TEXT NOT NULL DEFAULT (datetime('now'))\")\n        except sqlite3.OperationalError:\n            pass\n        \n        # Migration: Add ip_address column if it doesn't exist\n        try:\n            conn.execute(\"ALTER TABLE user_sessions ADD COLUMN ip_address TEXT NOT NULL DEFAULT 'unknown'\")\n        except sqlite3.OperationalError:\n            pass\n        \n        # Clean up expired sessions and states\n        conn.execute(\"DELETE FROM oauth_states WHERE expires_at < ?\", \n                    (datetime.now(timezone.utc).isoformat(),))\n        conn.execute(\"DELETE FROM user_sessions WHERE expires_at < ?\", \n                    (datetime.now(timezone.utc).isoformat(),))\n\n# Initialize tables when module is imported (for Gunicorn)\ntry:\n    init_dashboard_tables()\nexcept Exception as e:\n    # Fallback to print if logger not available during import\n    print(f\"‚ö†Ô∏è Dashboard initialization warning: {e}\")\n\n# OAuth Helper Functions\ndef create_oauth_state():\n    \"\"\"Generate and store OAuth state for CSRF protection\"\"\"\n    state = secrets.token_urlsafe(32)\n    expires_at = datetime.now(timezone.utc) + timedelta(minutes=10)\n    \n    with get_db() as conn:\n        conn.execute(\n            \"INSERT INTO oauth_states (state, expires_at) VALUES (?, ?)\",\n            (state, expires_at.isoformat())\n        )\n    return state\n\ndef verify_oauth_state(state):\n    \"\"\"Verify OAuth state and delete it\"\"\"\n    with get_db() as conn:\n        cursor = conn.execute(\n            \"SELECT state FROM oauth_states WHERE state = ? AND expires_at > ?\",\n            (state, datetime.now(timezone.utc).isoformat())\n        )\n        result = cursor.fetchone()\n        \n        if result:\n            conn.execute(\"DELETE FROM oauth_states WHERE state = ?\", (state,))\n            return True\n    return False\n\ndef exchange_code_for_token(code, redirect_uri):\n    \"\"\"Exchange authorization code for access token\"\"\"\n    data = {\n        'client_id': DISCORD_CLIENT_ID,\n        'client_secret': DISCORD_CLIENT_SECRET,\n        'grant_type': 'authorization_code',\n        'code': code,\n        'redirect_uri': redirect_uri\n    }\n    headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n    \n    response = requests.post(f'{DISCORD_API_BASE}/oauth2/token', data=data, headers=headers)\n    response.raise_for_status()\n    return response.json()\n\ndef get_user_info(access_token):\n    \"\"\"Get Discord user information\"\"\"\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = requests.get(f'{DISCORD_API_BASE}/users/@me', headers=headers)\n    response.raise_for_status()\n    return response.json()\n\ndef get_user_guilds(access_token):\n    \"\"\"Get user's Discord guilds\"\"\"\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = requests.get(f'{DISCORD_API_BASE}/users/@me/guilds', headers=headers)\n    response.raise_for_status()\n    return response.json()\n\ndef create_user_session(user_data, access_token, refresh_token, guilds_data):\n    \"\"\"Create user session in database\"\"\"\n    session_id = secrets.token_urlsafe(32)\n    created_at = datetime.now(timezone.utc)\n    expires_at = created_at + timedelta(hours=24)\n    # Get real client IP from proxy headers (falls back to remote_addr)\n    ip_address = request.access_route[0] if request.access_route else (request.remote_addr or 'unknown')\n    \n    with get_db() as conn:\n        conn.execute(\"\"\"\n            INSERT INTO user_sessions \n            (session_id, user_id, username, discriminator, avatar, access_token, refresh_token, guilds_data, created_at, expires_at, ip_address)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\", (\n            session_id,\n            user_data['id'],\n            user_data['username'],\n            user_data.get('discriminator', '0'),\n            user_data.get('avatar'),\n            access_token,\n            refresh_token,\n            json.dumps(guilds_data),\n            created_at.isoformat(),\n            expires_at.isoformat(),\n            ip_address\n        ))\n    return session_id\n\ndef get_user_session(session_id):\n    \"\"\"Get user session from database\"\"\"\n    with get_db() as conn:\n        cursor = conn.execute(\"\"\"\n            SELECT session_id, user_id, username, discriminator, avatar, access_token, guilds_data, expires_at\n            FROM user_sessions \n            WHERE session_id = ? AND expires_at > ?\n        \"\"\", (session_id, datetime.now(timezone.utc).isoformat()))\n        row = cursor.fetchone()\n        \n        if row:\n            return {\n                'session_id': row[0],\n                'user_id': row[1],\n                'username': row[2],\n                'discriminator': row[3] or '0',\n                'avatar': row[4],\n                'access_token': row[5],\n                'guilds': json.loads(row[6]) if row[6] else [],\n                'expires_at': row[7]\n            }\n    return None\n\ndef delete_user_session(session_id):\n    \"\"\"Delete user session from database\"\"\"\n    with get_db() as conn:\n        conn.execute(\"DELETE FROM user_sessions WHERE session_id = ?\", (session_id,))\n\ndef require_auth(f):\n    \"\"\"Decorator to require authentication\"\"\"\n    from functools import wraps\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        try:\n            session_id = session.get('session_id')\n            if not session_id:\n                app.logger.info(\"No session_id found, redirecting to login\")\n                return redirect('/auth/login')\n            \n            user_session = get_user_session(session_id)\n            if not user_session:\n                app.logger.warning(f\"Invalid or expired session: {session_id[:8]}...\")\n                session.clear()\n                return redirect('/auth/login')\n            \n            return f(user_session, *args, **kwargs)\n        except Exception as e:\n            app.logger.error(f\"Authentication error: {str(e)}\")\n            app.logger.error(traceback.format_exc())\n            session.clear()\n            return redirect('/auth/login')\n    return decorated_function\n\ndef require_api_auth(f):\n    \"\"\"Decorator to require authentication for API routes (returns JSON instead of redirect)\"\"\"\n    from functools import wraps\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        try:\n            session_id = session.get('session_id')\n            if not session_id:\n                return jsonify({'success': False, 'error': 'Unauthorized'}), 401\n            \n            user_session = get_user_session(session_id)\n            if not user_session:\n                session.clear()\n                return jsonify({'success': False, 'error': 'Session expired'}), 401\n            \n            return f(user_session, *args, **kwargs)\n        except Exception as e:\n            app.logger.error(f\"API authentication error: {str(e)}\")\n            app.logger.error(traceback.format_exc())\n            return jsonify({'success': False, 'error': 'Authentication error'}), 500\n    return decorated_function\n\ndef get_bot_guild_ids():\n    \"\"\"Get list of guild IDs where the bot is present (as strings for OAuth comparison)\"\"\"\n    try:\n        with get_db() as conn:\n            cursor = conn.execute(\"SELECT guild_id FROM bot_guilds\")\n            # Cast to string to match Discord OAuth guild IDs (which are strings)\n            return set(str(row[0]) for row in cursor.fetchall())\n    except Exception as e:\n        app.logger.error(f\"Error fetching bot guild IDs: {e}\")\n        # Return empty set to avoid 500 errors if table missing or locked\n        return set()\n\ndef user_has_admin_access(user_id, guild_id, user_guild):\n    \"\"\"\n    Check if user has admin access to a guild.\n    Returns True if user has:\n    - Discord Owner permissions, OR\n    - Discord Administrator permissions, OR\n    - A custom admin role configured via bot slash commands, OR\n    - The main admin role configured for the guild\n    \"\"\"\n    # Check Discord owner permission\n    if user_guild.get('owner', False):\n        return True\n    \n    # Check Discord administrator permission (0x8 = ADMINISTRATOR)\n    permissions = int(user_guild.get('permissions', '0'))\n    if permissions & 0x8:  # Administrator permission\n        return True\n    \n    # Check custom admin roles and main admin role from database\n    # Note: We can't easily get user's role IDs from OAuth guilds endpoint\n    # The guilds endpoint only gives us basic guild info and permissions\n    # For now, we'll trust Discord permissions (owner/administrator)\n    # Custom admin roles would require additional Discord API calls per guild\n    \n    # TODO: If needed, implement Discord API call to get member roles:\n    # GET /guilds/{guild_id}/members/{user_id} with bot token\n    # Then check against admin_roles and guild_settings.main_admin_role_id\n    \n    return False\n\ndef filter_user_guilds(user_session):\n    \"\"\"\n    Filter user's guilds to show only those where:\n    1. The bot is present (in bot_guilds table), AND\n    2. The user has admin access (owner, administrator, or custom admin role)\n    \"\"\"\n    all_guilds = user_session.get('guilds', [])\n    bot_guild_ids = get_bot_guild_ids()\n    filtered_guilds = []\n    \n    for guild in all_guilds:\n        guild_id = guild.get('id')\n        \n        # Check if bot is in this guild\n        if guild_id not in bot_guild_ids:\n            continue\n        \n        # Check if user has admin access\n        if not user_has_admin_access(user_session['user_id'], guild_id, guild):\n            continue\n        \n        # Guild passes both filters\n        filtered_guilds.append(guild)\n    \n    return filtered_guilds\n\n# Routes\n@app.route(\"/\")\ndef index():\n    \"\"\"Landing page with bot info, features, and upgrade links.\"\"\"\n    return render_template('landing.html')\n\n@app.route(\"/auth/login\")\ndef auth_login():\n    \"\"\"Redirect user to Discord OAuth\"\"\"\n    state = create_oauth_state()\n    redirect_uri = get_redirect_uri()\n    \n    params = {\n        'client_id': DISCORD_CLIENT_ID,\n        'redirect_uri': redirect_uri,\n        'response_type': 'code',\n        'scope': DISCORD_OAUTH_SCOPES,\n        'state': state\n    }\n    \n    auth_url = f'https://discord.com/oauth2/authorize?{urlencode(params)}'\n    app.logger.info(f\"OAuth login initiated - Redirect URI: {redirect_uri}\")\n    return redirect(auth_url)\n\n@app.route(\"/auth/callback\")\ndef auth_callback():\n    \"\"\"Handle Discord OAuth callback\"\"\"\n    try:\n        code = request.args.get('code')\n        state = request.args.get('state')\n        error = request.args.get('error')\n        \n        app.logger.info(f\"OAuth callback received - code: {'present' if code else 'missing'}, state: {'present' if state else 'missing'}, error: {error}\")\n        \n        if error:\n            app.logger.error(f\"OAuth error from Discord: {error}\")\n            return \"<h1>Authentication Error</h1><p>Unable to authenticate with Discord. Please try again.</p><a href='/'>Return Home</a>\", 400\n        \n        if not code or not state:\n            app.logger.error(\"Missing code or state in OAuth callback\")\n            return \"<h1>Authentication Error</h1><p>Invalid authentication request. Please try again.</p><a href='/'>Return Home</a>\", 400\n        \n        if not verify_oauth_state(state):\n            app.logger.error(f\"Invalid OAuth state: {state[:8]}... (CSRF check failed)\")\n            return \"<h1>Authentication Error</h1><p>Security validation failed. Please try again.</p><a href='/'>Return Home</a>\", 400\n        \n        # Exchange code for token (use same redirect_uri as in authorization)\n        redirect_uri = get_redirect_uri()\n        app.logger.info(f\"Exchanging code for token with redirect_uri: {redirect_uri}\")\n        token_data = exchange_code_for_token(code, redirect_uri)\n        access_token = token_data['access_token']\n        refresh_token = token_data.get('refresh_token')\n        \n        # Get user info\n        app.logger.info(\"Fetching user info from Discord\")\n        user_data = get_user_info(access_token)\n        app.logger.info(f\"User authenticated: {user_data.get('username')}\")\n        \n        # Get user's guilds\n        app.logger.info(\"Fetching user guilds\")\n        guilds_data = get_user_guilds(access_token)\n        app.logger.info(f\"Found {len(guilds_data)} guilds\")\n        \n        # Create session\n        session_id = create_user_session(user_data, access_token, refresh_token, guilds_data)\n        session['session_id'] = session_id\n        app.logger.info(f\"Session created: {session_id[:8]}...\")\n        \n        return redirect('/dashboard')\n        \n    except Exception as e:\n        app.logger.error(f\"OAuth callback error: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return \"<h1>Authentication Error</h1><p>An error occurred during authentication. Please try again later.</p><a href='/'>Return Home</a>\", 500\n\n@app.route(\"/auth/logout\")\ndef auth_logout():\n    \"\"\"Logout user\"\"\"\n    session_id = session.get('session_id')\n    if session_id:\n        delete_user_session(session_id)\n        app.logger.info(\"User session cleared\")\n    session.clear()\n    return redirect('/')\n\n@app.route(\"/dashboard\")\n@require_auth\ndef dashboard(user_session):\n    \"\"\"Protected dashboard showing user info and guilds where bot is present and user has admin access\"\"\"\n    try:\n        app.logger.info(f\"Dashboard accessed by user: {user_session.get('username')}\")\n        \n        # Filter guilds to show only where bot is present AND user has admin access\n        filtered_guilds = filter_user_guilds(user_session)\n        \n        # Create a modified user session with filtered guilds\n        dashboard_data = {\n            **user_session,\n            'guilds': filtered_guilds,\n            'total_guilds': len(user_session.get('guilds', [])),\n            'filtered_count': len(filtered_guilds)\n        }\n        \n        app.logger.info(f\"Showing {len(filtered_guilds)} of {len(user_session.get('guilds', []))} guilds\")\n        return render_template('dashboard.html', user=dashboard_data)\n    except Exception as e:\n        app.logger.error(f\"Dashboard rendering error: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return \"<h1>Error</h1><p>Unable to load dashboard. Please try again later.</p><a href='/auth/logout'>Logout</a>\", 500\n\ndef verify_guild_access(user_session, guild_id):\n    \"\"\"\n    Verify user has access to a specific guild.\n    Returns the guild object if user has access, None otherwise.\n    \"\"\"\n    all_guilds = user_session.get('guilds', [])\n    for guild in all_guilds:\n        if guild.get('id') == guild_id:\n            # Check if user has admin access to this guild\n            if user_has_admin_access(user_session['user_id'], guild_id, guild):\n                return guild\n    return None\n\ndef get_guild_roles_from_bot(guild_id):\n    \"\"\"\n    Fetch guild roles using Discord bot token.\n    Returns list of roles, or None if error.\n    Note: Members are fetched via separate API endpoint to avoid heavy initial page load.\n    \"\"\"\n    bot_token = os.environ.get('DISCORD_TOKEN')\n    if not bot_token:\n        app.logger.error(\"DISCORD_TOKEN not found in environment\")\n        return None\n    \n    headers = {'Authorization': f'Bot {bot_token}'}\n    try:\n        # Fetch guild roles only (lighter initial load)\n        roles_response = requests.get(\n            f'{DISCORD_API_BASE}/guilds/{guild_id}/roles',\n            headers=headers,\n            timeout=5\n        )\n        roles_response.raise_for_status()\n        roles = roles_response.json()\n        \n        return roles\n    except requests.exceptions.HTTPError as e:\n        if e.response.status_code == 403:\n            app.logger.error(f\"Bot lacks permissions to fetch roles for guild {guild_id}\")\n        elif e.response.status_code == 404:\n            app.logger.error(f\"Guild {guild_id} not found or bot not in guild\")\n        else:\n            app.logger.error(f\"HTTP error fetching guild roles: {str(e)}\")\n        return None\n    except Exception as e:\n        app.logger.error(f\"Error fetching guild roles: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return None\n\ndef get_guild_settings(guild_id):\n    \"\"\"\n    Fetch guild settings from database.\n    Returns dict with admin_roles, employee_roles, emails, timezone, etc.\n    \"\"\"\n    with get_db() as conn:\n        # Get admin roles (convert to strings to match Discord API format)\n        admin_cursor = conn.execute(\n            \"SELECT role_id FROM admin_roles WHERE guild_id = ?\",\n            (guild_id,)\n        )\n        admin_roles = [str(row[0]) for row in admin_cursor.fetchall()]\n        \n        # Get employee roles (convert to strings to match Discord API format)\n        employee_cursor = conn.execute(\n            \"SELECT role_id FROM employee_roles WHERE guild_id = ?\",\n            (guild_id,)\n        )\n        employee_roles = [str(row[0]) for row in employee_cursor.fetchall()]\n        \n        # Get guild settings (timezone, recipient_user_id, etc.)\n        settings_cursor = conn.execute(\n            \"SELECT timezone, recipient_user_id, name_display_mode FROM guild_settings WHERE guild_id = ?\",\n            (guild_id,)\n        )\n        settings_row = settings_cursor.fetchone()\n        \n        # Get main admin role\n        main_admin_cursor = conn.execute(\n            \"SELECT main_admin_role_id FROM guild_settings WHERE guild_id = ?\",\n            (guild_id,)\n        )\n        main_admin_row = main_admin_cursor.fetchone()\n        main_admin_role_id = main_admin_row[0] if main_admin_row and main_admin_row[0] else None\n        \n        return {\n            'admin_roles': admin_roles,\n            'employee_roles': employee_roles,\n            'timezone': settings_row[0] if settings_row else 'America/New_York',\n            'recipient_user_id': settings_row[1] if settings_row else None,\n            'name_display_mode': settings_row[2] if settings_row else 'username',\n            'main_admin_role_id': main_admin_role_id,\n            'emails': []  # TODO: Add email table and fetch emails\n        }\n\n@app.route(\"/server/<guild_id>/settings\")\n@require_auth\ndef server_settings(user_session, guild_id):\n    \"\"\"Server-specific settings page with admin/employee management, email, and timezone\"\"\"\n    try:\n        app.logger.info(f\"Server settings accessed for guild {guild_id} by user {user_session.get('username')}\")\n        \n        # Check if bot is present in this guild first (before expensive Discord API calls)\n        bot_guild_ids = get_bot_guild_ids()\n        if guild_id not in bot_guild_ids:\n            app.logger.warning(f\"Bot not present in guild {guild_id}\")\n            return \"<h1>Bot Not Present</h1><p>The On the Clock bot is not in this server. Please invite the bot first.</p><a href='/dashboard'>Back to Dashboard</a>\", 404\n        \n        # Verify user has access to this guild\n        guild = verify_guild_access(user_session, guild_id)\n        if not guild:\n            app.logger.warning(f\"User {user_session.get('username')} unauthorized for guild {guild_id}\")\n            return \"<h1>Access Denied</h1><p>You don't have admin access to this server.</p><a href='/dashboard'>Back to Dashboard</a>\", 403\n        \n        # Fetch guild roles from Discord (members loaded via API later)\n        roles = get_guild_roles_from_bot(guild_id)\n        if not roles:\n            app.logger.error(f\"Failed to fetch roles for guild {guild_id}\")\n            # Render page with error state but show existing settings\n            current_settings = get_guild_settings(guild_id)\n            return render_template('server_settings.html', \n                                   user=user_session, \n                                   guild=guild, \n                                   guild_id=guild_id, \n                                   roles=[],\n                                   current_settings=current_settings,\n                                   error=\"Could not fetch server roles. Please check bot permissions and try again.\"), 200\n        \n        # Fetch current settings from database\n        try:\n            current_settings = get_guild_settings(guild_id)\n        except Exception as e:\n            app.logger.error(f\"Error fetching guild settings: {str(e)}\")\n            # Use defaults if database error\n            current_settings = {\n                'admin_roles': [],\n                'employee_roles': [],\n                'timezone': 'America/New_York',\n                'recipient_user_id': None,\n                'name_display_mode': 'username',\n                'main_admin_role_id': None,\n                'emails': []\n            }\n        \n        # Prepare data for template\n        template_data = {\n            'user': user_session,\n            'guild': guild,\n            'guild_id': guild_id,\n            'roles': roles,\n            'current_settings': current_settings\n        }\n        \n        return render_template('server_settings.html', **template_data)\n    except Exception as e:\n        app.logger.error(f\"Server settings error: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return \"<h1>Error</h1><p>Unable to load server settings. Please try again later.</p><a href='/dashboard'>Back to Dashboard</a>\", 500\n\n# API Endpoints for Settings Management\n\ndef validate_role_in_guild(guild_id, role_id):\n    \"\"\"Validate that a role_id belongs to the specified guild\"\"\"\n    try:\n        roles = get_guild_roles_from_bot(guild_id)\n        if not roles:\n            return False\n        return any(str(role['id']) == str(role_id) for role in roles)\n    except Exception as e:\n        app.logger.error(f\"Error validating role: {str(e)}\")\n        return False\n\n@app.route(\"/api/server/<guild_id>/admin-roles/add\", methods=[\"POST\"])\n@require_api_auth\ndef api_add_admin_role(user_session, guild_id):\n    \"\"\"API endpoint to add an admin role\"\"\"\n    try:\n        # Verify user has access\n        guild = verify_guild_access(user_session, guild_id)\n        if not guild:\n            return jsonify({'success': False, 'error': 'Access denied'}), 403\n        \n        # Get role_id from request\n        data = request.get_json()\n        if not data or 'role_id' not in data:\n            return jsonify({'success': False, 'error': 'Missing role_id'}), 400\n        \n        role_id = str(data['role_id'])\n        \n        # Validate role belongs to guild\n        if not validate_role_in_guild(guild_id, role_id):\n            return jsonify({'success': False, 'error': 'Invalid role for this server'}), 400\n        \n        # Add role to database\n        with get_db() as conn:\n            conn.execute(\n                \"INSERT OR IGNORE INTO admin_roles (guild_id, role_id) VALUES (?, ?)\",\n                (guild_id, role_id)\n            )\n        \n        app.logger.info(f\"Added admin role {role_id} to guild {guild_id} by user {user_session.get('username')}\")\n        return jsonify({'success': True, 'message': 'Admin role added successfully', 'role_id': role_id})\n    except Exception as e:\n        app.logger.error(f\"Error adding admin role: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return jsonify({'success': False, 'error': 'Server error'}), 500\n\n@app.route(\"/api/server/<guild_id>/admin-roles/remove\", methods=[\"POST\"])\n@require_api_auth\ndef api_remove_admin_role(user_session, guild_id):\n    \"\"\"API endpoint to remove an admin role\"\"\"\n    try:\n        # Verify user has access\n        guild = verify_guild_access(user_session, guild_id)\n        if not guild:\n            return jsonify({'success': False, 'error': 'Access denied'}), 403\n        \n        # Get role_id from request\n        data = request.get_json()\n        if not data or 'role_id' not in data:\n            return jsonify({'success': False, 'error': 'Missing role_id'}), 400\n        \n        role_id = str(data['role_id'])\n        \n        # Remove role from database\n        with get_db() as conn:\n            conn.execute(\n                \"DELETE FROM admin_roles WHERE guild_id = ? AND role_id = ?\",\n                (guild_id, role_id)\n            )\n        \n        app.logger.info(f\"Removed admin role {role_id} from guild {guild_id} by user {user_session.get('username')}\")\n        return jsonify({'success': True, 'message': 'Admin role removed successfully', 'role_id': role_id})\n    except Exception as e:\n        app.logger.error(f\"Error removing admin role: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return jsonify({'success': False, 'error': 'Server error'}), 500\n\n@app.route(\"/api/server/<guild_id>/employee-roles/add\", methods=[\"POST\"])\n@require_api_auth\ndef api_add_employee_role(user_session, guild_id):\n    \"\"\"API endpoint to add an employee role\"\"\"\n    try:\n        # Verify user has access\n        guild = verify_guild_access(user_session, guild_id)\n        if not guild:\n            return jsonify({'success': False, 'error': 'Access denied'}), 403\n        \n        # Get role_id from request\n        data = request.get_json()\n        if not data or 'role_id' not in data:\n            return jsonify({'success': False, 'error': 'Missing role_id'}), 400\n        \n        role_id = str(data['role_id'])\n        \n        # Validate role belongs to guild\n        if not validate_role_in_guild(guild_id, role_id):\n            return jsonify({'success': False, 'error': 'Invalid role for this server'}), 400\n        \n        # Add role to database\n        with get_db() as conn:\n            conn.execute(\n                \"INSERT OR IGNORE INTO employee_roles (guild_id, role_id) VALUES (?, ?)\",\n                (guild_id, role_id)\n            )\n        \n        app.logger.info(f\"Added employee role {role_id} to guild {guild_id} by user {user_session.get('username')}\")\n        return jsonify({'success': True, 'message': 'Employee role added successfully', 'role_id': role_id})\n    except Exception as e:\n        app.logger.error(f\"Error adding employee role: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return jsonify({'success': False, 'error': 'Server error'}), 500\n\n@app.route(\"/api/server/<guild_id>/employee-roles/remove\", methods=[\"POST\"])\n@require_api_auth\ndef api_remove_employee_role(user_session, guild_id):\n    \"\"\"API endpoint to remove an employee role\"\"\"\n    try:\n        # Verify user has access\n        guild = verify_guild_access(user_session, guild_id)\n        if not guild:\n            return jsonify({'success': False, 'error': 'Access denied'}), 403\n        \n        # Get role_id from request\n        data = request.get_json()\n        if not data or 'role_id' not in data:\n            return jsonify({'success': False, 'error': 'Missing role_id'}), 400\n        \n        role_id = str(data['role_id'])\n        \n        # Remove role from database\n        with get_db() as conn:\n            conn.execute(\n                \"DELETE FROM employee_roles WHERE guild_id = ? AND role_id = ?\",\n                (guild_id, role_id)\n            )\n        \n        app.logger.info(f\"Removed employee role {role_id} from guild {guild_id} by user {user_session.get('username')}\")\n        return jsonify({'success': True, 'message': 'Employee role removed successfully', 'role_id': role_id})\n    except Exception as e:\n        app.logger.error(f\"Error removing employee role: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return jsonify({'success': False, 'error': 'Server error'}), 500\n\n@app.route(\"/api/server/<guild_id>/timezone\", methods=[\"POST\"])\n@require_api_auth\ndef api_update_timezone(user_session, guild_id):\n    \"\"\"API endpoint to update timezone\"\"\"\n    try:\n        # Verify user has access\n        guild = verify_guild_access(user_session, guild_id)\n        if not guild:\n            return jsonify({'success': False, 'error': 'Access denied'}), 403\n        \n        # Get timezone from request\n        data = request.get_json()\n        if not data or 'timezone' not in data:\n            return jsonify({'success': False, 'error': 'Missing timezone'}), 400\n        \n        timezone_str = data['timezone']\n        \n        # Validate timezone\n        try:\n            from zoneinfo import ZoneInfo, available_timezones\n            if timezone_str not in available_timezones():\n                return jsonify({'success': False, 'error': 'Invalid timezone'}), 400\n        except Exception as tz_error:\n            app.logger.error(f\"Timezone validation error: {str(tz_error)}\")\n            return jsonify({'success': False, 'error': 'Invalid timezone'}), 400\n        \n        # Update or insert guild settings\n        with get_db() as conn:\n            # Check if settings exist\n            cursor = conn.execute(\"SELECT guild_id FROM guild_settings WHERE guild_id = ?\", (guild_id,))\n            exists = cursor.fetchone()\n            \n            if exists:\n                conn.execute(\n                    \"UPDATE guild_settings SET timezone = ? WHERE guild_id = ?\",\n                    (timezone_str, guild_id)\n                )\n            else:\n                conn.execute(\n                    \"INSERT INTO guild_settings (guild_id, timezone) VALUES (?, ?)\",\n                    (guild_id, timezone_str)\n                )\n        \n        app.logger.info(f\"Updated timezone to {timezone_str} for guild {guild_id} by user {user_session.get('username')}\")\n        return jsonify({'success': True, 'message': 'Timezone updated successfully', 'timezone': timezone_str})\n    except Exception as e:\n        app.logger.error(f\"Error updating timezone: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return jsonify({'success': False, 'error': 'Server error'}), 500\n\n@app.route(\"/api/server/<guild_id>/data\", methods=[\"GET\"])\n@require_api_auth\ndef api_get_server_data(user_session, guild_id):\n    \"\"\"API endpoint to fetch server roles and settings for dashboard integration\"\"\"\n    try:\n        # Verify user has access\n        guild = verify_guild_access(user_session, guild_id)\n        if not guild:\n            return jsonify({'success': False, 'error': 'Access denied'}), 403\n        \n        # Check if bot is present\n        bot_guild_ids = get_bot_guild_ids()\n        if guild_id not in bot_guild_ids:\n            return jsonify({'success': False, 'error': 'Bot not present in this server'}), 404\n        \n        # Fetch guild roles\n        roles = get_guild_roles_from_bot(guild_id)\n        if not roles:\n            return jsonify({'success': False, 'error': 'Could not fetch server roles'}), 500\n        \n        # Fetch current settings\n        current_settings = get_guild_settings(guild_id)\n        \n        return jsonify({\n            'success': True,\n            'guild': guild,\n            'roles': roles,\n            'current_settings': current_settings\n        })\n    except Exception as e:\n        app.logger.error(f\"Error fetching server data: {str(e)}\")\n        app.logger.error(traceback.format_exc())\n        return jsonify({'success': False, 'error': 'Server error'}), 500\n\n@app.route(\"/invite\")\ndef invite():\n    \"\"\"Redirect to Discord bot invite link.\"\"\"\n    # Bot invite with essential permissions\n    bot_id = \"1418446753379913809\"\n    permissions = \"2048\"  # Slash commands permission\n    invite_url = f\"https://discord.com/api/oauth2/authorize?client_id={bot_id}&permissions={permissions}&scope=bot%20applications.commands\"\n    return f'<script>window.location.href=\"{invite_url}\";</script><a href=\"{invite_url}\">Click here if you are not redirected</a>'\n\n@app.route(\"/favicon.ico\")\ndef favicon():\n    \"\"\"Return empty favicon to prevent 404 errors.\"\"\"\n    from flask import Response\n    return Response('', mimetype='image/x-icon')\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get(\"PORT\", 5000))\n    debug = os.environ.get(\"FLASK_ENV\") != \"production\"\n    \n    print(f\"üåê Starting Landing Page Server...\")\n    print(f\"üîß Environment: {os.environ.get('FLASK_ENV', 'development')}\")\n    print(f\"üåê Port: {port}\")\n    print(f\"üêõ Debug: {debug}\")\n    \n    # Run Flask app\n    app.run(host=\"0.0.0.0\", port=port, debug=debug)","size_bytes":35996},"start.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nStartup script to run Discord bot and simple landing page.\nLanding page only - no authentication complexity.\n\"\"\"\nimport os\nimport subprocess\nimport threading\nimport time\nimport signal\nimport sys\n\ndef run_discord_bot():\n    \"\"\"Run the Discord bot in a separate thread.\"\"\"\n    print(\"ü§ñ Starting Discord Bot...\")\n    try:\n        result = subprocess.run([sys.executable, \"bot.py\"], \n                              capture_output=False, \n                              text=True)\n        if result.returncode != 0:\n            print(f\"‚ùå Discord bot exited with code {result.returncode}\")\n    except Exception as e:\n        print(f\"‚ùå Error running Discord bot: {e}\")\n\ndef run_landing_page():\n    \"\"\"Run the Flask app with Gunicorn production server.\"\"\"\n    print(\"üåê Starting Landing Page with Gunicorn...\")\n    try:\n        # Run Gunicorn with proper configuration\n        result = subprocess.run([\n            \"gunicorn\", \n            \"app:app\",\n            \"--bind\", \"0.0.0.0:5000\",\n            \"--workers\", \"2\",\n            \"--timeout\", \"120\",\n            \"--access-logfile\", \"-\",\n            \"--error-logfile\", \"-\"\n        ], capture_output=False, text=True)\n        \n        if result.returncode != 0:\n            print(f\"‚ùå Gunicorn exited with code {result.returncode}\")\n    except Exception as e:\n        print(f\"‚ùå Error running Gunicorn: {e}\")\n\ndef signal_handler(sig, frame):\n    \"\"\"Handle shutdown signals gracefully.\"\"\"\n    print(\"\\nüõë Shutting down services...\")\n    os._exit(0)\n\ndef main():\n    \"\"\"Main startup function.\"\"\"\n    print(\"üöÄ Starting On the Clock Bot & Landing Page...\")\n    print(\"=\" * 60)\n    \n    # Set up signal handlers for graceful shutdown\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n    \n    # Start Discord bot in background thread\n    bot_thread = threading.Thread(target=run_discord_bot, daemon=True)\n    bot_thread.start()\n    \n    # Give bot a moment to start\n    time.sleep(2)\n    \n    # Run landing page in main thread (blocks until exit)\n    print(\"üåê Landing page will be available on port 5000\")\n    print(\"ü§ñ Discord bot running in background\")\n    print(\"=\" * 60)\n    \n    try:\n        run_landing_page()\n    except KeyboardInterrupt:\n        print(\"\\nüõë Received shutdown signal\")\n    except Exception as e:\n        print(f\"‚ùå Fatal error: {e}\")\n    finally:\n        print(\"üëã Services stopped\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":2483},"DISCORD_AUTH_REFERENCE.md":{"content":"# Discord OAuth 2.0 Implementation Reference\n\n**Version**: 1.0 (September 2025)  \n**Framework**: Flask + Discord.py  \n**Deployment**: Replit VM\n\n---\n\n## Quick Start\n\nThis reference documents a production-ready Discord OAuth 2.0 implementation for Flask applications, including all lessons learned and gotchas encountered during development.\n\n## Core Concept\n\nDiscord OAuth allows users to log in with their Discord account and grants your app access to:\n- User profile (avatar, username, ID)\n- List of Discord servers the user is in\n- User's roles and permissions in each server\n\n## Architecture\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     OAuth     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Discord   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   Flask App  ‚îÇ\n‚îÇ   OAuth     ‚îÇ               ‚îÇ  (app.py)    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                                     ‚îÇ\n                                     ‚ñº\n                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                              ‚îÇ  SQLite DB  ‚îÇ\n                              ‚îÇ  Sessions   ‚îÇ\n                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Implementation Files\n\n### 1. Flask Application (app.py)\n\nKey components:\n\n```python\nfrom flask import Flask, session, redirect, request, render_template\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nimport logging\n\napp = Flask(__name__)\napp.secret_key = os.environ.get('SECRET_KEY', secrets.token_hex(32))\n\n# CRITICAL: Enable ProxyFix for Replit\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1, x_for=1)\n\n# Configure logging for Gunicorn\nif __name__ != '__main__':\n    gunicorn_logger = logging.getLogger('gunicorn.error')\n    app.logger.handlers = gunicorn_logger.handlers\n    app.logger.setLevel(gunicorn_logger.level)\n```\n\n### OAuth Routes\n\n```python\n@app.route(\"/auth/login\")\ndef auth_login():\n    \"\"\"Redirect to Discord OAuth\"\"\"\n    state = create_oauth_state()  # CSRF token\n    redirect_uri = get_redirect_uri()\n    \n    params = {\n        'client_id': DISCORD_CLIENT_ID,\n        'redirect_uri': redirect_uri,\n        'response_type': 'code',\n        'scope': 'identify guilds',  # Request permissions\n        'state': state\n    }\n    \n    auth_url = f'https://discord.com/oauth2/authorize?{urlencode(params)}'\n    return redirect(auth_url)\n\n@app.route(\"/auth/callback\")\ndef auth_callback():\n    \"\"\"Handle Discord OAuth callback\"\"\"\n    code = request.args.get('code')\n    state = request.args.get('state')\n    \n    # Verify CSRF token\n    if not verify_oauth_state(state):\n        return \"Security validation failed\", 400\n    \n    # Exchange code for token\n    token_data = exchange_code_for_token(code, get_redirect_uri())\n    access_token = token_data['access_token']\n    \n    # Get user data\n    user_data = get_user_info(access_token)\n    guilds_data = get_user_guilds(access_token)\n    \n    # Create session\n    session_id = create_user_session(user_data, access_token, guilds_data)\n    session['session_id'] = session_id\n    \n    return redirect('/dashboard')\n\n@app.route(\"/dashboard\")\n@require_auth  # Decorator checks session\ndef dashboard(user_session):\n    return render_template('dashboard.html', user=user_session)\n```\n\n### 2. Custom Jinja2 Filter (CRITICAL!)\n\n**Problem**: Jinja2 doesn't support bitwise operators (`&`, `|`, `^`)\n\n**Solution**: Custom filter\n\n```python\n@app.template_filter('has_permission')\ndef has_permission(permissions, permission_flag):\n    \"\"\"Check if a permission integer has a specific flag\"\"\"\n    try:\n        return int(permissions) & permission_flag != 0\n    except (ValueError, TypeError):\n        return False\n```\n\n**Usage in Template**:\n```jinja\n{% if guild.permissions|has_permission(0x8) %}\n    <span class=\"badge\">Administrator</span>\n{% elif guild.permissions|has_permission(0x20) %}\n    <span class=\"badge\">Manage Server</span>\n{% endif %}\n```\n\n**Common Discord Permission Flags**:\n- `0x8` - Administrator\n- `0x20` - Manage Server\n- `0x10` - Manage Channels\n- `0x2` - Kick Members\n- `0x4` - Ban Members\n\n### 3. Database Schema\n\n```sql\n-- OAuth CSRF tokens (temporary)\nCREATE TABLE oauth_states (\n    state TEXT PRIMARY KEY,\n    expires_at TEXT NOT NULL\n);\n\n-- User sessions (persistent)\nCREATE TABLE user_sessions (\n    session_id TEXT PRIMARY KEY,\n    user_id TEXT NOT NULL,\n    username TEXT NOT NULL,\n    access_token TEXT NOT NULL,\n    guilds_data TEXT NOT NULL,  -- JSON string\n    created_at TEXT NOT NULL,\n    expires_at TEXT NOT NULL\n);\n```\n\n### 4. Helper Functions\n\n```python\ndef create_oauth_state():\n    \"\"\"Generate CSRF protection token\"\"\"\n    state = secrets.token_urlsafe(32)\n    expires_at = datetime.now(timezone.utc) + timedelta(minutes=10)\n    \n    with get_db() as conn:\n        conn.execute(\n            \"INSERT INTO oauth_states (state, expires_at) VALUES (?, ?)\",\n            (state, expires_at.isoformat())\n        )\n    return state\n\ndef verify_oauth_state(state):\n    \"\"\"Verify and consume CSRF token (one-time use)\"\"\"\n    with get_db() as conn:\n        cursor = conn.execute(\n            \"SELECT state FROM oauth_states WHERE state = ? AND expires_at > ?\",\n            (state, datetime.now(timezone.utc).isoformat())\n        )\n        result = cursor.fetchone()\n        \n        if result:\n            # Delete after use (one-time)\n            conn.execute(\"DELETE FROM oauth_states WHERE state = ?\", (state,))\n            return True\n    return False\n\ndef exchange_code_for_token(code, redirect_uri):\n    \"\"\"Exchange authorization code for access token\"\"\"\n    data = {\n        'client_id': DISCORD_CLIENT_ID,\n        'client_secret': DISCORD_CLIENT_SECRET,\n        'grant_type': 'authorization_code',\n        'code': code,\n        'redirect_uri': redirect_uri\n    }\n    \n    response = requests.post(\n        'https://discord.com/api/v10/oauth2/token',\n        data=data,\n        headers={'Content-Type': 'application/x-www-form-urlencoded'}\n    )\n    response.raise_for_status()\n    return response.json()\n\ndef get_user_info(access_token):\n    \"\"\"Fetch user profile from Discord\"\"\"\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = requests.get(\n        'https://discord.com/api/v10/users/@me',\n        headers=headers\n    )\n    response.raise_for_status()\n    return response.json()\n\ndef get_user_guilds(access_token):\n    \"\"\"Fetch user's Discord servers\"\"\"\n    headers = {'Authorization': f'Bearer {access_token}'}\n    response = requests.get(\n        'https://discord.com/api/v10/users/@me/guilds',\n        headers=headers\n    )\n    response.raise_for_status()\n    return response.json()\n```\n\n## Security Best Practices\n\n### 1. Never Expose Internal Errors to Users\n\n‚ùå **Bad**:\n```python\nexcept Exception as e:\n    return f\"Error: {str(e)}\", 500  # Leaks internal details!\n```\n\n‚úÖ **Good**:\n```python\nexcept Exception as e:\n    app.logger.error(f\"OAuth callback error: {str(e)}\")\n    app.logger.error(traceback.format_exc())\n    return \"An error occurred. Please try again later.\", 500\n```\n\n### 2. Redact Sensitive Values in Logs\n\n‚ùå **Bad**:\n```python\napp.logger.error(f\"Invalid OAuth state: {state}\")  # Full token logged!\n```\n\n‚úÖ **Good**:\n```python\napp.logger.error(f\"Invalid OAuth state: {state[:8]}... (CSRF check failed)\")\n```\n\n### 3. Use Database Sessions (Not In-Memory)\n\n**Why**: Gunicorn workers can restart, causing in-memory sessions to be lost.\n\n‚úÖ **Good**: Store sessions in SQLite/PostgreSQL\n\n### 4. CSRF Protection\n\nAlways use `state` parameter for OAuth to prevent CSRF attacks:\n1. Generate random state token before redirecting to Discord\n2. Store in database with expiration\n3. Verify state when Discord redirects back\n4. Delete state after one-time use\n\n## Environment Variables\n\nRequired for OAuth:\n```bash\nDISCORD_CLIENT_ID=your_client_id\nDISCORD_CLIENT_SECRET=your_client_secret\nSECRET_KEY=random_secret_for_flask_sessions\n```\n\nOptional but recommended:\n```bash\nDISCORD_REDIRECT_URI=https://yourdomain.replit.app/auth/callback\n```\n\n## Replit Deployment\n\n### Configuration (.replit)\n\n```toml\n[deployment]\ndeploymentTarget = \"vm\"  # Use VM, not autoscale\nrun = [\"python\", \"start.py\"]  # If combining with Discord bot\n```\n\n### Why VM?\n\n- **Persistent state** required for Discord bot\n- **Database** needs to persist\n- **Background processes** (bot runs alongside web server)\n\n### start.py Pattern\n\nIf you're running a Discord bot + OAuth dashboard:\n\n```python\nimport subprocess\nimport threading\nimport time\n\ndef run_discord_bot():\n    subprocess.run([\"python\", \"bot.py\"])\n\ndef run_flask_app():\n    subprocess.run([\n        \"gunicorn\", \"app:app\",\n        \"--bind\", \"0.0.0.0:5000\",\n        \"--workers\", \"2\"\n    ])\n\ndef main():\n    # Start bot in background\n    bot_thread = threading.Thread(target=run_discord_bot, daemon=True)\n    bot_thread.start()\n    \n    time.sleep(2)  # Let bot initialize\n    \n    # Run Flask in main thread\n    run_flask_app()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Common Issues & Solutions\n\n### Issue: Jinja2 Template Error\n\n**Symptom**: Template fails to render with \"expected token 'end of print statement'\"\n\n**Cause**: Using bitwise operator in template:\n```jinja\n{% if guild.permissions|int & 0x8 %}  {# ‚ùå Won't work #}\n```\n\n**Solution**: Use custom filter:\n```jinja\n{% if guild.permissions|has_permission(0x8) %}  {# ‚úÖ Works #}\n```\n\n### Issue: Port 5000 Already in Use\n\n**Symptom**: `Address already in use` error\n\n**Cause**: Old Gunicorn processes still running\n\n**Solution**:\n```bash\n# Find processes\nps aux | grep gunicorn\n\n# Kill all\npkill -9 gunicorn\n\n# Or kill specific PID\nkill -9 <PID>\n```\n\n### Issue: Database Initialization Fails During Deployment\n\n**Symptom**: Deployment errors mentioning app.logger\n\n**Cause**: Using `app.logger` before Gunicorn initializes it\n\n**Solution**: Wrap initialization:\n```python\ntry:\n    init_dashboard_tables()\nexcept Exception as e:\n    print(f\"‚ö†Ô∏è Dashboard initialization warning: {e}\")\n```\n\n### Issue: Sessions Don't Persist Across Restarts\n\n**Symptom**: Users logged out when workflow restarts\n\n**Cause**: Using Flask's default in-memory sessions\n\n**Solution**: Use database-backed sessions (as shown in this reference)\n\n### Issue: OAuth Callback Shows \"Invalid State\"\n\n**Symptom**: CSRF validation fails\n\n**Possible Causes**:\n1. State token expired (check expiration time)\n2. Database connection issue\n3. State already used (one-time tokens)\n\n**Debug**:\n```python\napp.logger.info(f\"Received state: {state[:8]}...\")\n# Check if state exists in database\n```\n\n## Dashboard Template Example\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Dashboard - {{ user.username }}</title>\n</head>\n<body>\n    <div class=\"profile\">\n        <img src=\"https://cdn.discordapp.com/avatars/{{ user.user_id }}/{{ user.avatar }}.png\">\n        <h1>{{ user.username }}</h1>\n        <p>ID: {{ user.user_id }}</p>\n    </div>\n    \n    <div class=\"servers\">\n        <h2>Your Servers ({{ user.guilds|length }})</h2>\n        {% for guild in user.guilds %}\n        <div class=\"server\">\n            <h3>{{ guild.name }}</h3>\n            {% if guild.owner %}\n                <span class=\"badge owner\">üëë Owner</span>\n            {% elif guild.permissions|has_permission(0x8) %}\n                <span class=\"badge admin\">‚ö° Administrator</span>\n            {% elif guild.permissions|has_permission(0x20) %}\n                <span class=\"badge manage\">üîß Manage Server</span>\n            {% endif %}\n        </div>\n        {% endfor %}\n    </div>\n</body>\n</html>\n```\n\n## Testing Checklist\n\nBefore deploying:\n\n- [ ] OAuth login redirects to Discord correctly\n- [ ] Discord redirects back to callback URL\n- [ ] State token verification works\n- [ ] User session created and stored in database\n- [ ] Dashboard displays user profile\n- [ ] Server list shows with correct permissions\n- [ ] Logout clears session\n- [ ] Sessions persist across workflow restarts\n- [ ] Error messages are generic (no sensitive data)\n- [ ] Logs contain detailed errors for debugging\n\n## References\n\n- [Discord OAuth Documentation](https://discord.com/developers/docs/topics/oauth2)\n- [Discord Permissions Calculator](https://discordapi.com/permissions.html)\n- [Flask Documentation](https://flask.palletsprojects.com/)\n- [Werkzeug ProxyFix](https://werkzeug.palletsprojects.com/en/stable/middleware/proxy_fix/)\n\n---\n\n**Last Updated**: September 30, 2025  \n**Tested On**: Replit VM Deployment  \n**Status**: Production-Ready ‚úÖ\n","size_bytes":12514}},"version":1}
./.pythonlibs/lib/python3.11/site-packages/flask/app.py:274:            self.add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/app.py:1020:        :meth:`@app.route() <route>`, and usually the same name as the
./.pythonlibs/lib/python3.11/site-packages/flask/ctx.py:126:        @app.route('/')
./.pythonlibs/lib/python3.11/site-packages/flask/ctx.py:167:        @app.route('/')
./.pythonlibs/lib/python3.11/site-packages/flask/helpers.py:542:        @app.route("/uploads/<path:name>")
./.pythonlibs/lib/python3.11/site-packages/flask/views.py:33:        app.add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/views.py:160:        app.add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/app.py:605:    def add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/app.py:626:                ' example: @app.route(..., methods=["POST"])'
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/blueprints.py:87:    def add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/blueprints.py:110:        self.app.add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/blueprints.py:324:            state.add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/blueprints.py:413:    def add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/blueprints.py:434:            lambda s: s.add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/scaffold.py:343:            @app.route("/")
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/scaffold.py:362:            self.add_url_rule(rule, endpoint, f, **options)
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/scaffold.py:368:    def add_url_rule(
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/scaffold.py:382:            @app.route("/")
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/scaffold.py:391:            app.add_url_rule("/", view_func=index)
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/scaffold.py:411:            app.add_url_rule("/", endpoint="index")
./.pythonlibs/lib/python3.11/site-packages/flask/sansio/scaffold.py:443:            app.add_url_rule("/ex", endpoint="example")
./.pythonlibs/lib/python3.11/site-packages/flask-3.1.2.dist-info/METADATA:65:@app.route("/")
./.pythonlibs/lib/python3.11/site-packages/flask_session-0.8.0.dist-info/METADATA:112:    @app.route('/set/')
./.pythonlibs/lib/python3.11/site-packages/flask_session-0.8.0.dist-info/METADATA:117:    @app.route('/get/')
./.config/.semgrep/semgrep_rules.json:35134:          "pattern-inside": "@app.route(...)\ndef $X(...):\n  ...\n"
./.config/.semgrep/semgrep_rules.json:35300:          "pattern-inside": "@app.route(...)\ndef $X(filename):\n  ...\n"
./DISCORD_AUTH_REFERENCE.md:62:@app.route("/auth/login")
./DISCORD_AUTH_REFERENCE.md:79:@app.route("/auth/callback")
./DISCORD_AUTH_REFERENCE.md:103:@app.route("/dashboard")
./app.py:362:@app.route("/")
./app.py:367:@app.route("/auth/login")
./app.py:385:@app.route("/auth/callback")
./app.py:436:@app.route("/auth/logout")
./app.py:446:@app.route("/dashboard")
./app.py:565:@app.route("/server/<guild_id>/settings")
./app.py:642:@app.route("/api/server/<guild_id>/admin-roles/add", methods=["POST"])
./app.py:691:@app.route("/api/server/<guild_id>/admin-roles/remove", methods=["POST"])
./app.py:736:@app.route("/api/server/<guild_id>/employee-roles/add", methods=["POST"])
./app.py:785:@app.route("/api/server/<guild_id>/employee-roles/remove", methods=["POST"])
./app.py:830:@app.route("/api/server/<guild_id>/timezone", methods=["POST"])
./app.py:880:@app.route("/api/server/<guild_id>/data", methods=["GET"])
./app.py:914:@app.route("/invite")
./app.py:923:@app.route("/favicon.ico")
